# 2026-02-09 GPT Discussion

## 현재 상태

### 구현 완료
- **MC1 Mask Cleanup Pipeline** (`qa/mask_cleanup.py`)
  - CCF (Connected Component Filtering): pred_center에 가장 가까운 컴포넌트만 유지
  - 조건부 Erosion: 컴포넌트가 1개(전부 연결)이면 erode→CCF→dilate로 얇은 연결 끊기
  - Expected Region AND: baseline 면적+종횡비 기반 타원으로 과도 확산 차단
  - 트리거: shape_score < 0.8
  - 파이프라인: SAM2 mask → ShapeStats 1차 → cleanup → ShapeStats 2차 → fusion

### MC1 테스트 결과 (수치)
| 설정 | ACTIVE | OCCLUDED | UNCERTAIN | RESEED |
|------|--------|----------|-----------|--------|
| Baseline (모두 기본) | 383 | 176 | 14 | 1 |
| MC1 단독 | 473 (+90) | 51 (-125) | 21 | 1 |
| P2 단독 (state_roi_expansion ON) | 526 (+143) | 96 | 3 | 1 |
| MC1 + P2 | **569 (+186)** | 99 | 26 | 1 |

### 17개 토글 전체 목록 (현재 기본값)
```
[ON ] F1  active_reacquire_split       ACTIVE/REACQUIRE 모드 분리
[OFF] F2  soft_pred_penalty            pred 거리 소프트 페널티
[ON ] F3  strict_consensus             엄격 consensus (None=불합의)
[OFF] F4  area_continuity_penalty      면적 연속성 감점
[ON ] F5  reacquire_active_recovery    REACQUIRE→ACTIVE 복귀
[OFF] P1  speed_roi_expansion          속도 기반 ROI 확장
[OFF] P2  state_roi_expansion          UNCERTAIN/OCCLUDED ROI 1.25x
[OFF] P3  expansion_cooldown           ROI 확장 쿨다운 5프레임
[OFF] P4  sam2_bbox_sync               SAM2 bbox 독립 동기화
[OFF] P5  reacquire_box_expansion      REACQUIRE 시 box prompt 확장
[ON ] S1  composite_mask_selection     복합 점수 마스크 선택
[ON ] S2  template_update_gating       TPL 업데이트 품질 게이팅
[ON ] S3  klt_divergence_reinit        KLT 발산 재초기화
[ON ] S4  sam2_mask_caching            SAM2 결과 캐싱
[ON ] SH1 shape_quality_gate           shape 기반 마스크 거부
[OFF] MC1 mask_cleanup                 번짐 감지 시 CCF+Expected Region
[ON ] K1  velocity_decay_on_predict    predict-only 속도 감쇠
[OFF] SM1 occluded_to_uncertain_recovery  OCCLUDED→UNCERTAIN 복귀
```

### 단일 토글 A/B 테스트 결과 (baseline ACTIVE=383 대비)
| Toggle | ACTIVE | OCCLUDED | RESEED | 판정 |
|--------|--------|----------|--------|------|
| SH1_OFF | 714 (+331) | 27 | 0 | **FAKE** — 배경 추적 |
| MC1_ON | **473 (+90)** | **51** | 1 | 좋음 (OCCLUDED 71% 감소) |
| P2_ON | 526 (+143) | 96 | 1 | 좋음 (육안 확인됨) |
| F3_OFF | 565 (+182) | 72 | 1 | 좋지만 교차검증 약화 위험 |
| F2_ON | 489 (+106) | 141 | 1 | 보통 |
| P4_ON | 452 (+69) | 295 | 0 | 보통 |
| S3_OFF | 424 (+41) | 136 | 1 | 미미 |
| P1_ON | 383 (±0) | 176 | 1 | 무효과 |
| S2_OFF | 383 (±0) | 176 | 1 | 무효과 |
| F1_OFF | 329 (-54) | 114 | 2 | 해로움 |
| F4_ON | 318 (-65) | 126 | 2 | 해로움 |
| S4_OFF | 274 (-109) | 77 | 2 | 해로움 |
| S1_OFF | 283 (-100) | 68 | 2 | 해로움 |
| F5_OFF | 265 (-118) | 56 | 2 | 해로움 |
| K1_OFF | 미완 | | | |
| SM1_ON | 미완 | | | |

### 합의된 다음 단계 (2026-02-07)
- P0: Mask Cleanup ✅ 완료
- P1: mask_input (last_good only, 오염 시 금지)
- P2: prompt 개선 (box shrink + multi-positive)

---

## 논의 주제

### 1. MC1 결과 분석 — UNCERTAIN 증가 현상

MC1 ON 시 OCCLUDED가 크게 줄었지만 UNCERTAIN이 소폭 증가함:
- Baseline: UNCERTAIN=14 → MC1: UNCERTAIN=21 → MC1+P2: UNCERTAIN=26

**가설**: cleanup으로 마스크를 살렸지만, 정리된 마스크의 quality가 완전하지 않아
fusion에서 SAM2 채택은 되지만 quality_score가 낮아 UNCERTAIN 판정.

**질문**: 이 UNCERTAIN 증가가 문제인가? 아니면 "OCCLUDED(완전 실패)보다 UNCERTAIN(불확실하지만 추적 중)"이 더 나은 상태이므로 허용 가능한가?

### 2. MC1 파라미터 튜닝 필요성

현재 하드코딩된 값들:
- **트리거 임계값**: shape_score < 0.8 (cleanup 시도 기준)
- **Erosion**: kernel 3x3, iterations=2
- **Expected Region**: baseline × 1.5 배율
- **과도 절삭 방지**: result_area < baseline × 0.2 이면 취소

**질문**: 이 파라미터들을 config.yaml에 노출해야 하나? 아니면 현재 고정값으로 충분한가?

### 3. 다음 우선순위 — 토글 조합 탐색 vs Phase 2 진행

**옵션 A**: 토글 조합 최적화 먼저
- MC1 + P2 + F3 조합
- MC1 + P2 + F2 조합
- K1, SM1 미완 테스트 완료
- 최적 조합 확정 → config.yaml 기본값 변경

**옵션 B**: Phase 2 (mask_input) 진행
- last_good mask logits를 SAM2 predict()에 전달
- 오염 방지 조건 구현
- 번짐 근본 원인 대응

**옵션 C**: MC1 자체를 먼저 개선
- cleanup이 실패하는 케이스 분석 (overlay 기반)
- 파라미터 튜닝
- 추가 cleanup 전략 (예: contour smoothing)

**질문**: 어떤 순서가 가장 효율적인가?

### 4. F3 (strict_consensus OFF)와 MC1 조합의 안전성

F3 OFF = TPL/KLT가 None이면 합의 통과 → SAM2 단독 채택 가능.
MC1이 있으면 번짐 마스크가 정리되어 SAM2 결과가 더 깨끗해짐.

**가설**: MC1 + F3_OFF 조합이면, F3 OFF의 "교차검증 약화" 위험이 MC1의 "마스크 정리"로 보완될 수 있음.
→ SAM2가 단독 채택되더라도, 번짐은 cleanup으로 걸러지니까.

**질문**: 이 논리가 맞는가? MC1이 F3 OFF의 안전장치가 될 수 있는가?

### 5. 장기적 관점 — 어떤 수준이면 "충분히 좋은" 추적인가?

현재 255프레임, 3트랙 기준:
- 이론적 최대 ACTIVE = 765 (3 × 255)
- 현재 최고 MC1+P2 = 569 (74.4%)
- NEEDS_RESEED = 1 (1개 트랙 실패)

**질문**:
- 목표 ACTIVE 비율은?
- NEEDS_RESEED = 0을 목표로 해야 하나?
- 다른 영상에서도 테스트해야 하는 시점은 언제인가?


# 2026-02-09 코드 리뷰 기반 제안 (MC1/UNCERTAIN/F3/우선순위)

## 0) 전제: "ACTIVE 카운트" 최적화는 이미 실패한 지표임
- SH1_OFF에서 ACTIVE=714가 나온 건 "배경/오탐 추적"이어서, ACTIVE 비율 자체는 목적함수가 될 수 없음.
- 앞으로는 아래 3개를 같이 봐야 함:
  1) NEEDS_RESEED 최소화
  2) 드리프트/오탐(특히 CONSENSUS_BREAK, AREA_BLOWUP, CENTER_JUMP) 최소화
  3) OCCLUDED(업데이트 없음) 시간 최소화 + (가능하면) 짧은 gap로 유지

---

## 1) MC1 ON 시 UNCERTAIN 증가: 문제라기보다 '정상적인' 부작용
### 왜 늘어나는가 (코드 레벨)
- runner.py에서 MC1은 shape_score<0.8일 때 실행 → cleanup 후에도 shape_score가 0.6~0.75대에 머무는 케이스가 생김
- fusion.py에서 ACTIVE는 quality>=0.7, REACQUIRE는 더 관대하지만 state_hint가 UNCERTAIN으로 떨어질 수 있음
- 즉 MC1이 "OCCLUDED로 버릴 프레임"을 "업데이트는 가능한데 확신은 낮은 프레임"으로 바꿔서 UNCERTAIN이 늘어나는 구조

### 결론
- UNCERTAIN 증가는 자체로 문제라고 보기 어려움 (OCCLUDED보다 훨씬 낫다)
- 단, **UNCERTAIN에서 Kalman update를 너무 강하게 걸면 드리프트 위험** → 아래 1-1이 필수

### 1-1) 즉시 고쳐야 할 핵심: Kalman measurement noise를 quality에 따라 동적으로 키우기
- 현재 fusion.py는 SAM2를 채택하면 quality가 낮아도 measurement_r = sam2_r(=10) 고정
- UNCERTAIN/저품질 프레임에서 update를 하더라도, KF가 measurement를 덜 믿게 해야 안전함
- 제안:
  - measurement_r = base_r * f(quality)
  - 예: q>=0.8 → r=base_r
        0.6<=q<0.8 → r=base_r * (1 + 2*(0.8-q)/0.2)  (최대 3배)
        q<0.6 → update 금지 또는 r=base_r*5
- 효과: UNCERTAIN이 늘어도 "드리프트 없이 버티는 불확실성"으로 바뀜

---

## 2) MC1 파라미터: 전부 노출 X, '안전 관련'만 최소 노출 O
### 지금 하드코딩 값의 문제
- mask_cleanup.py:
  - trigger는 현재 runner에서 shape_score<0.8 하나뿐
  - erosion kernel/iter, expected_region scale(1.5), min_area_ratio(0.2) 등 전부 고정
- 고정값은 영상/배율/ROI 크기/개체 크기 바뀌면 바로 깨질 가능성이 큼

### 제안: config에 최소 4개만 노출
- qa.mask_cleanup:
  - trigger_shape: 0.8 (또는 0.75로 내려서 과도 트리거 완화)
  - expected_scale: 1.5
  - erosion_iters: 2
  - min_area_ratio: 0.2
- 나머지는 자동 스케일 권장:
  - erosion_iters를 baseline_thickness_med나 seed_bbox_size 기반으로 결정 (개체 크기 따라 달라야 함)

### 추가로 꼭 넣을 "자기 검증" 로직 (튜닝보다 중요)
- cleanup 적용 후 shape_score/area/border_touch가 개선되지 않으면 원본 유지:
  - if cleaned_shape_score < original_shape_score + delta: revert
  - if cleaned_area 너무 작거나(현재 0.2) 또는 center가 pred에서 멀어지면 revert
- 이렇게 하면 파라미터가 좀 틀려도 “나쁜 cleanup”이 자동으로 걸러짐

---

## 3) 다음 우선순위: (B) Phase2 전에 (1-1)만 먼저 하고 들어가자
### 추천 순서 (효율/리스크 기준)
1) [필수] Kalman measurement_r를 quality 기반 동적으로 조정 (작업량 작고 안전성 크게 상승)
2) Phase2: last_good 기반 프롬프트 강화
   - mask_input(가능하면 logits) 또는
   - 최소한 multi-positive point(예: pred + tpl + klt + prev_good 내부 샘플 포인트)
3) 그 다음에 토글 조합을 확정해 default로 잠그기

### 이유
- Phase2는 근본 원인(번짐/오염된 prompt 누적)을 줄여서 MC1 같은 휴리스틱 의존도를 낮춤
- 하지만 Phase2 넣기 전에 update 안정성이 없으면, 개선이 실제인지/드리프트인지 해석이 어려워짐

---

## 4) F3_OFF + MC1 = 안전장치? → "부분적으로만" 가능, 현재 논리는 위험
### 왜 MC1이 F3_OFF의 안전장치가 되기 어려운가
- F3_OFF는 "TPL/KLT가 None이어도 has_consensus=True가 될 수 있음" → ACTIVE에서도 SAM2 단독 채택 가능
- MC1은 "번짐/연결"을 줄일 뿐, SAM2가 아예 다른 대상(다른 개체/배경 덩어리)을 잡는 걸 막기 어렵다
- 특히 pred_center가 이미 틀어진 상태면, CCF도 틀린 컴포넌트를 고를 수 있음

### 대안: '상태 의존 consensus'로 목적만 취하기
- F3를 전역 OFF하지 말고:
  - ACTIVE에서는 strict consensus 강제
  - REACQUIRE에서만 consensus 완화(또는 penalty만 적용)
- 즉 "F3_OFF로 얻는 ACTIVE 증가"의 이점은 REACQUIRE에서만 가져가고,
  ACTIVE에서의 오탐 위험은 유지 차단

---

## 5) "충분히 좋은" 기준 제안 (현재 지표 재정의)
### ACTIVE 목표치 자체는 의미가 약함
- ACTIVE/UNCERTAIN/OCCLUDED 분류는 내부 규칙 결과라서,
  잘못 추적해도 ACTIVE가 늘 수 있음(=SH1_OFF 사례)

### 대신 다음을 목표로 잡는 게 현실적
- NEEDS_RESEED: 실험 클립(수백 프레임) 단위에서는 0 목표가 타당
- 오탐/드리프트 대리지표:
  - CONSENSUS_BREAK 플래그 빈도 (특히 sensor_used=SAM2일 때)
  - AREA_BLOWUP / CENTER_JUMP 빈도
  - MERGED 상태에서 복귀 실패 비율
- gap 품질:
  - OCCLUDED의 "연속 길이"가 짧아야 함 (총합보다 연속 최대 길이가 더 중요)

### 다른 영상 테스트 시점
- Phase2(프롬프트/last_good) + 동적R 까지 들어간 뒤,
  최소 3개 다른 조건 클립(속도/가림/조명 다른 것)에서 동일 세팅으로 깨지는지 확인해야 과적합 방지 가능

---

## 6) MC1 자체 개선 포인트 (코드 레벨)
- expected_region에서 aspect_ratio를 max(ar,1)로 clamp하면 세로형(AR<1) 정보가 사라짐
  - ar_norm = max(ar, 1/ar) 또는 seed_bbox 기반으로 축 길이 결정 권장
- expected_region이 axis-aligned ellipse라 방향성이 반영되지 않음
  - velocity 방향 또는 prev_good endpoints PCA 방향을 angle로 넣는 "rotated ellipse"가 더 강력한 차단이 될 수 있음
- CCF 기준점이 pred_center만인 것도 위험
  - tpl/klt가 있으면 (pred, tpl, klt)의 가중 평균/median을 기준점으로 쓰는 게 더 안전
- 디버깅 강화를 위해 debug record에 다음 필드 추가 권장:
  - mc1_applied(bool), mc1_step("ccf"/"erode"/"expected"), area_before/after, shape_before/after

---
---

# 2026-02-09 구현 결과 보고 — Dynamic R 실패 및 육안 검증

## 1. 이번에 적용한 코드 변경 3가지

GPT 리뷰 의견을 반영하여 다음 코드 변경을 적용함.

### 변경 1: Dynamic measurement_r (`qa/fusion.py`)

GPT 제안 1-1 그대로 구현. SAM2 채택 시 quality에 따라 Kalman measurement_r 스케일링.

```python
# fusion.py에 추가된 함수
def _quality_r_scale(base_r: float, quality: float) -> float:
    if quality >= 0.8:
        return base_r                           # 고신뢰: R 그대로
    if quality >= 0.6:
        scale = 1.0 + 2.0 * (0.8 - quality) / 0.2  # 1.0 ~ 3.0
        return base_r * scale                   # 저신뢰: R 최대 3배
    return base_r * 5.0                         # 극저: R 5배 (거의 무시)
```

적용 위치: `_fuse_case_a_split()`의 ACTIVE/REACQUIRE 경로 + `_fuse_case_a_base()`.
FusionResult 반환 직전에 `effective_r = _quality_r_scale(effective_r, adjusted_quality)` 호출.

### 변경 2: MC1 self-verification (`pipeline/runner.py`)

cleanup 후 shape_score가 개선되지 않으면 원본 유지하도록 변경.

```python
# runner.py c-3 단계 — 변경 전
if was_cleaned:
    sam2_result = rebuild_sensor_result(cleaned, roi, roi_shape)
    shape_stats = analyze_mask(cleaned, prev_ss, roi_shape)

# runner.py c-3 단계 — 변경 후 (self-verification)
if was_cleaned:
    cleaned_stats = analyze_mask(cleaned, prev_ss, roi_shape)
    if cleaned_stats.shape_score > original_score:   # ← 이 조건
        sam2_result = rebuild_sensor_result(cleaned, roi, roi_shape)
        shape_stats = cleaned_stats
```

→ **결과**: 너무 엄격함. cleanup이 번짐을 제거해도 면적 축소로 shape_score가 미세하게 낮아지는 경우 revert됨.
→ `>= original - 0.1` (delta 완화)도 시도했으나 여전히 regression.
→ **최종적으로 self-verification 제거하고 원래 MC1 로직(항상 적용)으로 복원**.

### 변경 3: MC1 aspect_ratio 버그 수정 (`qa/mask_cleanup.py`)

```python
# 변경 전
ar = max(baseline_aspect_ratio, 1.0)

# 변경 후
ar = max(baseline_aspect_ratio, 1.0 / max(baseline_aspect_ratio, 0.01))
```

세로형 벌레(ar < 1)에서 정보 손실 방지. 실제 shape_analyzer는 `max(w,h)/min(w,h) >= 1`로 계산하므로 영향은 제한적.

---

## 2. 테스트 출력물 목록 및 각 설정 차이

모든 출력물은 `video/short.mp4` (255프레임, 3트랙) 기준.

### 2026-02-07 출력물 (dynamic R 없음, self-verification 없음)

| 출력 폴더 | MC1 | P2 | dynamic R | self-verify | 비고 |
|-----------|-----|-----|-----------|-------------|------|
| `output/2026-02-07/mc1_off/` | OFF | OFF | 없음 | 없음 | 이전 baseline |
| `output/2026-02-07/mc1_on/` | **ON** | OFF | 없음 | 없음 | MC1 단독 |
| `output/2026-02-07/mc1_p2/` | **ON** | **ON** | 없음 | 없음 | **육안 검증 최고** |

### 2026-02-09 출력물 (dynamic R 추가)

| 출력 폴더 | MC1 | P2 | dynamic R | self-verify | 비고 |
|-----------|-----|-----|-----------|-------------|------|
| `output/2026-02-09/baseline/` | OFF | OFF | **있음** | 없음 | dynamic R만 적용된 baseline |
| `output/2026-02-09/mc1_on/` | **ON** | OFF | **있음** | **strict (>)** | 첫 시도: self-verify strict |
| `output/2026-02-09/mc1_p2/` | **ON** | **ON** | **있음** | **strict (>)** | 첫 시도 |
| `output/2026-02-09/mc1_on_v2/` | **ON** | OFF | **있음** | **delta (-0.1)** | self-verify 완화 |
| `output/2026-02-09/mc1_p2_v2/` | **ON** | **ON** | **있음** | **delta (-0.1)** | self-verify 완화 |
| `output/2026-02-09/mc1_on_v3/` | **ON** | OFF | **있음** | 없음(제거) | self-verify 완전 제거 |
| `output/2026-02-09/mc1_p2_v3/` | **ON** | **ON** | **있음** | 없음(제거) | self-verify 완전 제거 |

### 수치 비교 (전체)

| 출력 | ACTIVE | OCCLUDED | UNCERTAIN | RESEED |
|------|--------|----------|-----------|--------|
| **07/mc1_off** (이전 baseline) | 383 | 176 | 14 | 1 |
| **07/mc1_on** (MC1 단독) | 473 | 51 | 21 | 1 |
| **07/mc1_p2** (MC1+P2, 원본) | **569** | 99 | 26 | 1 |
| **09/baseline** (dynamic R만) | 457 | 102 | 14 | 1 |
| 09/mc1_on (strict) | 380 | 126 | 27 | 2 |
| 09/mc1_p2 (strict) | 426 | 196 | 52 | 1 |
| 09/mc1_on_v2 (delta) | 384 | 127 | 27 | 2 |
| 09/mc1_p2_v2 (delta) | 487 | 206 | 61 | 1 |
| 09/mc1_on_v3 (no verify) | 384 | 124 | 27 | 2 |
| 09/mc1_p2_v3 (no verify) | 371 | 126 | 9 | 2 |

**핵심**: dynamic R 적용 후 MC1이 있는 모든 조합에서 regression 발생 (RESEED 증가, ACTIVE 감소).

---

## 3. 육안 검증 결과 (사용자 관측, 상세)

### 3-1. MC1 단독 (mc1_on, mc1_on_v2, mc1_on_v3) — 세 버전 모두 유사하게 나쁨

**파란 벌레 (Track 2)**:
- 거의 시작하자마자 추적 놓쳐서 종료

**초록 벌레 (Track 1)**:
- 초반 한 번의 큰 움직임을 쫓은 이후 이파리(배경)로 추적이 튐
- 추적 놓친 뒤, 한참 뒤에 벌레가 추적 영역 위에서 머물며 다시 벌레를 추적 시작

**빨간 벌레 (Track 3)**:
- 별도 언급 없음 (상대적으로 안정)

→ P2 없이 MC1만으로는 ROI가 좁아 SAM2가 큰 움직임을 놓침.

### 3-2. MC1+P2 원본 (`07/mc1_p2`, dynamic R 없음) — **가장 좋은 추적**

**파란 벌레**:
- 초반~중반까지 거의 완벽하게 추적
- 후반에 벌레들이 거의 정지한 후, 갑자기 바깥으로 추적이 튀다가 다른 벌레를 마스킹하며 영상 종료
- 추적이 튈 때 **SAM2 box가 작은 형태로 제어** → 배경 잎으로 번지는 것은 차단되는 것처럼 보임
- 하지만 **벌레와 상관없는 영역으로 방향성과 속도감 있게 튀면서 이동**하는 현상

**초록 벌레**:
- 첫 큰 움직임만 쫓은 후, 제자리 맴돌 때 **주변 풀잎으로 마스킹이 자꾸 튀는 불안정한 상태**
- 다시 큰 움직임 시 추적 놓치고 풀잎 영역을 돌아다니며 추적
- 이후 파란 벌레 영역으로 튀며 마스킹이 불안정하게 커졌다 작아졌다 반복
- 최종적으로 추적 사망 → NEEDS_RESEED

### 3-3. MC1+P2+dynamic R v2 (`09/mc1_p2_v2`, self-verify delta) — **악화**

**파란 벌레**:
- 초반 양상은 원본과 비슷하나, 벌레가 거의 정지할 때부터 문제 발생
- **인접 벌레 침입**: 옆의 다른 벌레가 파란 벌레의 box 영역 안으로 들어올 때, 한 프레임 정도 **두 벌레를 동시에 마스킹**
- **연쇄 오염**: 옆의 마스킹(초록)이 배경으로 튈 때, 몇 프레임 동안 **파란 마스킹도 배경으로 같이 튐**
- **Bbox 불일치 (핵심 문제)**: SAM2 마스킹은 이쁘게 벌레를 감싸고 있는데, **상자는 벌레 전체를 감싸지 않고 길쭉한 직사각형**이 벌레의 중앙을 중심으로 벌레의 일부분만 포함, 일부분은 박스 밖에 있는 형태 → OCCLUDED 상태
- **프레임 깜빡임**: 벌레에 정확히 마스킹되었다가 → 박스 모양대로 마스킹되었다가를 **프레임 단위로 깜빡이듯 반복**
- **초록에 끌려감**: 초록 마스킹이 풀잎으로 튀어 파란 벌레 주위에 생성되었을 때, 파란 마스킹도 배경으로 튀어 원래 초록 벌레 쪽으로 쭉 이동 → OCCLUDED 상태로 머물다 마지막에 해당 벌레 모양대로 마스킹하며 영상 종료

**초록 벌레**:
- 첫 움직임 이후 배경으로 마스킹이 튐
- 그 뒤로 **벌레를 피해 배경을 마스킹**하다가, 벌레가 마스킹 영역에 재진입하자 벌레를 다시 추적
- 벌레가 거의 정지 시: **벌레는 세로로 길게 있는데 박스는 가로로 길게 그려진 영역** → UNCERTAIN/OCCLUDED
- 갑자기 옆 벌레 주변으로 마스킹 이동, 옆 벌레 배경 영역을 마스킹

### 3-4. MC1+P2+dynamic R v3 (`09/mc1_p2_v3`, self-verify 제거) — **최악**

**파란 벌레**:
- 벌레 영역을 잘 마스킹하고 박스 처리도 잘 되다가, 벌레가 거의 정지했을 때부터 문제
- **마스킹은 벌레 모양대로** 되어 있는데, **박스는 벌레 위치를 중심으로 그려지지만 벌레를 감싸지 않은 가로로 길쭉한 형태**로 표시
- → OCCLUDED → **추적 사망(RESEED)**

**초록 벌레**:
- 벌레의 **첫 움직임에서 바로 놓침**
- 혼자 벌레의 첫 움직임 방향에 해당하는 배경으로 튐
- **그 방향대로 쭉 움직이며 배경 추적** → 방향성과 속도감 있게 접시 외곽까지 나감
- → **RESEED**로 추적 사망

**v3가 원본보다 전체적으로 추적 성능이 확연히 안 좋아짐.**

---

## 4. 원인 분석

### 문제 1: Dynamic R이 velocity 드리프트를 유발

Dynamic R이 `measurement_r`을 높이면 Kalman update에서 measurement 가중치가 낮아짐.
→ prediction(= 위치 + **velocity**)을 더 신뢰.
→ velocity가 잘못된 방향이면, **그 방향으로 가속 드리프트** 발생.

v3에서 관측된 "방향성과 속도감 있게 접시 외곽까지 이동"이 정확히 이 현상.

**기존 K1 velocity_decay_on_predict와의 차이**:
- K1: `do_kalman_update=False`일 때만 velocity × 0.5 감쇠
- Dynamic R: `do_kalman_update=True`(R만 높임), velocity 감쇠 안 됨
- → Dynamic R은 update를 수행하므로 K1이 작동하지 않음

### 문제 2: Bbox 불일치 (seed_bbox 고정 크기/비율)

SAM2 prompt: `box = [kalman_pred_cx - half_w, kalman_pred_cy - half_h, ...]`
여기서 `half_w`, `half_h`는 **seed_bbox(초기 시드 크기)에서 고정**.

벌레가 회전하거나 방향이 바뀌면 seed_bbox와 실제 형태가 불일치:
- 벌레가 세로로 있는데 box는 가로 → box 안에 벌레 일부만 포함
- SAM2는 box 밖의 벌레 부분을 놓침 → 불완전 마스크
- → shape_score 하락 → SH1 reject → OCCLUDED

이 문제는 dynamic R과 독립적이지만, dynamic R로 인한 prediction 편향이 bbox 위치까지 밀리면 악화.

### 문제 3: MC1과 Dynamic R의 상호작용

```
Dynamic R 단독:
  shape_score 낮음 → quality 낮음 → R 높음 → KF prediction 신뢰 → 안정적 대기 ✓

MC1 + Dynamic R:
  shape_score 낮음 → MC1 cleanup → shape_score 올라감 → quality 올라감
  → R 낮아짐(보호 해제) → 불완전한 cleanup centroid를 KF가 강하게 반영
  → 드리프트 ✗
```

MC1이 quality 신호를 인위적으로 올려서 dynamic R의 보호를 우회하는 구조.

---

## 5. 질문

1. **Dynamic R의 velocity 드리프트 문제를 어떻게 해결하는가?**
   - (a) dynamic R 적용 시 velocity도 비례적으로 감쇠?
   - (b) R이 일정 이상이면 update 대신 predict-only?
   - (c) dynamic R 자체를 포기하고 다른 접근?

2. **Bbox 불일치 문제 (seed_bbox 고정)**
   - P4 (sam2_bbox_sync) 토글이 이걸 해결하려 했지만, 이전 A/B에서 OCCLUDED=295로 크게 악화됨
   - seed_bbox를 SAM2 마스크 bbox로 **점진적으로** 갱신하는 방법은?
   - bbox 갱신 시 shape_score 조건을 걸어야 하는가?

3. **MC1+P2 원본(dynamic R 없음)이 현재 최적인데, 여기서 더 개선하려면?**
   - 정지 시 잎맥 번짐은 여전히 발생 (근본 해결 안 됨)
   - mask_input(Phase 2)가 근본 해결인가? 아니면 bbox 문제를 먼저 해야 하는가?

4. **추적이 "방향성 있게 튀는" 현상은 velocity 문제만인가?**
   - 아니면 SAM2 prompt box가 잘못된 위치로 이동 → 그 위치에서 새 대상 포착 → 그 대상으로 Kalman update → 양성 피드백 루프?
