# 2026-02-07 GPT Discussion — SAM2 잎맥 번짐 문제 대응 전략

## 배경

### 현재 파이프라인 (per-track, per-frame)
```
Kalman predict → ROI crop → 3 Sensors (SAM2, Template, KLT)
  → ShapeStats 분석 → QA Fusion → KF update → State Machine → bbox/template 갱신
```

- **SAM2**: 주 센서. ROI 내에서 box+point prompt → segmentation mask → centroid 추출
- **Template (TPL)**: Gray+Sobel NCC 매칭. SAM2 교차검증용 보조 센서
- **KLT**: 광학 흐름 기반 feature tracking. SAM2 교차검증용 보조 센서
- **QA Fusion**: SAM2 결과를 TPL/KLT와 교차검증하여 채택/거부 결정
- **ShapeStats**: skeleton 기반 마스크 형태 분석 (tube_fit, width_cv 등)

### 16개 Feature Toggle 상세 설명

각 토글은 `config.yaml`의 `toggles:` 섹션에서 ON/OFF.
**기본값(baseline)**: 아래 표의 "기본" 열 참조.

#### Fusion 토글 (qa/fusion.py)

| ID | 이름 | 기본 | ON 동작 | OFF 동작 |
|----|------|------|---------|----------|
| F1 | `active_reacquire_split` | **ON** | ACTIVE 모드(엄격: consensus 필수)와 REACQUIRE 모드(관대: consensus 없어도 채택)를 분리. ACTIVE에서 consensus 실패 시 거부 | 단일 경로. ACTIVE/REACQUIRE 구분 없이 동일 조건으로 SAM2 채택 |
| F2 | `soft_pred_penalty` | OFF | SAM2↔predict 거리가 임계값 초과해도 즉시 거부하지 않고, quality 감점 + measurement_R 증가로 소프트 처리 | **하드 게이트**: 거리 > 임계값이면 SAM2 즉시 거부 (predict-only) |
| F3 | `strict_consensus` | **ON** | TPL/KLT가 None(측정 실패)이면 합의 실패 처리. **센서가 존재하고** SAM2와 가까워야 합의 인정 | None이면 합의 통과 처리. 센서 결과가 없으면 "반대하지 않았으므로" 합의로 간주 |
| F4 | `area_continuity_penalty` | OFF | 이전 프레임 대비 면적 급변 시 quality 감점 (0.5배 미만 또는 2배 초과) | 면적 연속성 검사 안 함 |
| F5 | `reacquire_active_recovery` | **ON** | UNCERTAIN/OCCLUDED에서 consensus + quality ≥ 0.8 충족 시 ACTIVE로 복귀 허용 | REACQUIRE 모드에서는 항상 UNCERTAIN hint만 반환 (ACTIVE 직접 복귀 불가) |

#### Pipeline / ROI 토글 (pipeline/runner.py)

| ID | 이름 | 기본 | ON 동작 | OFF 동작 |
|----|------|------|---------|----------|
| P1 | `speed_roi_expansion` | OFF | Kalman 속도 > 임계값이면 ROI 1.5x 확장 (빠른 이동 대응) | ROI 크기 고정 (base_size 기반) |
| P2 | `state_roi_expansion` | OFF | UNCERTAIN/OCCLUDED 상태에서 ROI를 **1.25x 확장** → SAM2가 더 넓은 영역 탐색 | 상태 무관하게 ROI 크기 고정 |
| P3 | `expansion_cooldown` | OFF | ROI 확장 후 ACTIVE 복귀 시 5프레임 동안 서서히 축소 (히스테리시스) | 확장/축소 즉시 전환 |
| P4 | `sam2_bbox_sync` | OFF | SAM2 마스크의 bbox를 매 프레임 track.bbox에 동기화 (sensor_used와 무관) | sensor_used=="SAM2"일 때만 bbox 갱신 |
| P5 | `reacquire_box_expansion` | OFF | REACQUIRE 시 SAM2 box prompt를 ROI expansion 비율만큼 확장 | box prompt 크기 항상 seed_bbox 크기 고정 |

#### Sensor 토글

| ID | 이름 | 기본 | ON 동작 | OFF 동작 |
|----|------|------|---------|----------|
| S1 | `composite_mask_selection` | **ON** | SAM2 multi-mask 중 복합 점수(SAM2 score + pred 근접성 + 면적 일관성 + border_touch) 최고 마스크 선택 | argmax(SAM2 scores)로 단순 선택 |
| S2 | `template_update_gating` | **ON** | SAM2 quality ≥ 0.7일 때만 TPL 템플릿 갱신 (나쁜 프레임으로 템플릿 오염 방지) | 매 프레임 무조건 갱신 |
| S3 | `klt_divergence_reinit` | **ON** | KLT↔SAM2 거리 > 임계값이면 KLT feature points 재초기화 | KLT 발산해도 유지 |
| S4 | `sam2_mask_caching` | **ON** | QA 통과한 SAM2 결과(mask, center, area) 캐시. 다음 프레임 prev_area로 면적 연속성 검사에 사용 | 캐시 없음. prev_area=None → 면적 연속성 검사 불가 |

#### Shape / Kalman / State Machine

| ID | 이름 | 기본 | ON 동작 | OFF 동작 |
|----|------|------|---------|----------|
| SH1 | `shape_quality_gate` | **ON** | shape_score < 0.6: 전체 거부(predict-only). < 0.8: bbox HOLD + cache 차단 + quality 감점 | shape 분석 결과를 무시. 모든 SAM2 마스크 형태 무관하게 통과 |
| K1 | `velocity_decay_on_predict` | **ON** | predict-only (SAM2 거부) 시 Kalman 속도를 0.5x 감쇠 → 드리프트 억제 | 속도 감쇠 없음. predict-only 시 마지막 속도 유지 → 직선 드리프트 |
| SM1 | `occluded_to_uncertain_recovery` | OFF | OCCLUDED 상태에서 UNCERTAIN hint 받으면 UNCERTAIN으로 전환 (재획득 시도) | OCCLUDED에서 UNCERTAIN 복귀 불가. ACTIVE hint 필요 |

### A/B 테스트에서 가장 좋았던 설정

**P2_state_roi_ON** 테스트 시 실제 적용된 전체 토글 상태:
```
[ON ] F1  active_reacquire_split    ← ACTIVE/REACQUIRE 모드 분리
[OFF] F2  soft_pred_penalty          ← pred 거리 하드 게이트
[ON ] F3  strict_consensus           ← 엄격 consensus (None=불합의)
[OFF] F4  area_continuity_penalty
[ON ] F5  reacquire_active_recovery  ← REACQUIRE→ACTIVE 복귀 허용
[OFF] P1  speed_roi_expansion
[ON ] P2  state_roi_expansion        ← ★ 변경: UNCERTAIN/OCCLUDED에서 ROI 1.25x
[OFF] P3  expansion_cooldown
[OFF] P4  sam2_bbox_sync
[OFF] P5  reacquire_box_expansion
[ON ] S1  composite_mask_selection   ← 복합 점수 마스크 선택
[ON ] S2  template_update_gating     ← TPL 업데이트 품질 게이팅
[ON ] S3  klt_divergence_reinit      ← KLT 발산 재초기화
[ON ] S4  sam2_mask_caching          ← SAM2 결과 캐싱
[ON ] SH1 shape_quality_gate         ← shape 기반 마스크 거부
[ON ] K1  velocity_decay_on_predict  ← predict-only 속도 감쇠
[OFF] SM1 occluded_to_uncertain_recovery
```

**F3_strict_OFF** 테스트 시 차이점:
```
[OFF] F3  strict_consensus  ← ★ 변경: None=합의 통과 (TPL/KLT 없어도 SAM2 채택)
```
이 경우 TPL/KLT가 측정 실패하거나 발산해도 SAM2가 단독으로 채택됨.
→ SAM2가 정확하면 좋지만, SAM2가 번지면 교차검증 없이 번짐 수용.

### 육안 검증 결과 (P2_state_roi_ON / F3_strict_OFF)
이 조합이 **지금까지 가장 좋은 추적**:
- 초록 벌레: 첫 큰 움직임에 SAM2가 정확히 따라감 (기존엔 항상 놓침)
- 파란 벌레: 이전에 전혀 추적 안 되던 것이 초반 추적 성공 (돌파)
- 빨간 벌레: 안정적. 머리 1/4만 빠지고 몸통 3/4 추적

### 핵심 문제: SAM2 잎맥 번짐 (Vein Bleeding)

벌레가 제자리 맴돌 때 어두운 잎맥으로 SAM2 마스크 번짐:
```
정상 추적 → 정지/느린 움직임 → 잎맥으로 마스크 번짐 → 벌레가 ROI 밖 이탈 → 추적 실패
```

번짐 조건:
- 벌레 정지 또는 느린 움직임
- 근처에 어두운 잎맥 (높은 대비 경계)
- SAM2가 잎맥 텍스처를 벌레 경계와 혼동

## 논의 주제 — 번짐 대응 방안

### 현재 SAM2 prompt 전략
```python
# Box prompt: Kalman 예측 center + seed bbox 크기
box = [cx - half_w, cy - half_h, cx + half_w, cy + half_h]

# Point prompt: Kalman 예측 위치 1개 (positive)
point_coords = [[cx_roi, cy_roi]]
point_labels = [1]  # positive

# Mask input: 없음 (사용 안 함)
```

### 현재 품질 게이트 (SH1)
```python
# fusion.py
if shape_score < 0.6:
    # 전체 거부 → predict-only (OCCLUDED)
    return PRED

# runner.py
if shape_score < 0.8:
    # bbox HOLD + cache 차단 + quality 감점
```
**문제**: 거부만 하고 복구 시도가 없음. predict-only → 위치 드리프트 축적

### 방안 1: Connected Component Filtering (마스크 후처리)

번짐 감지 시 SAM2 마스크를 connected component로 분리, 예측 위치에 가장 가까운 컴포넌트만 유지.

```
[번짐 마스크]          [필터링 후]
 ██████████          ██████
 ████ ← 잎맥         (잎맥 제거)
 ██████████          ██████
```

**장점**: 번짐 부분만 제거하고 벌레 부분 보존 가능
**단점**: 벌레-잎맥이 완전히 연결되면 분리 불가
**구현**: SAM2 출력 직후, shape_score 검사 전에 적용

```python
# 번짐 감지 시
if shape_score < threshold:
    # 1) 마스크를 connected components로 분리
    # 2) pred center에 가장 가까운 component만 유지
    # 3) 너무 작으면 fallback
    cleaned_mask = keep_nearest_component(mask, pred_center)
    # re-analyze shape
```

### 방안 2: Morphological Erosion + Reconnect

마스크를 약간 침식(erode)하여 벌레-잎맥 사이의 얇은 연결을 끊은 후, 벌레 쪽만 유지.

```python
eroded = cv2.erode(mask, kernel_3x3, iterations=2)
# connected component에서 pred 근처 것만 유지
# 다시 dilate로 원래 크기 복원
```

**장점**: 얇은 연결 효과적으로 끊음
**단점**: 작은 벌레가 erosion으로 사라질 수 있음

### 방안 3: SAM2 mask_input 활용 (시간적 일관성)

SAM2 predict()에 이전 좋은 마스크를 mask_input으로 전달하여 시간 연속성 유도.

```python
masks, scores, _ = predictor.predict(
    box=box[None, :],
    point_coords=point_coords,
    point_labels=point_labels,
    mask_input=prev_good_mask_logits,  # <-- 새로 추가
    multimask_output=True,
)
```

**장점**: SAM2가 이전 프레임 마스크를 참조하여 자연스러운 연속성
**단점**: 이전 마스크가 이미 번져있으면 번짐 전파
**주의**: 캐시된 "마지막 좋은 마스크"만 사용해야 함

### 방안 4: Negative Point Prompt

번짐 감지 시, 잎맥 영역에 negative point를 추가하여 해당 영역 배제.

```python
# 번짐 영역의 중심을 negative point로
neg_point = find_bleed_center(current_mask, prev_good_mask)
point_coords = [[cx, cy], [neg_x, neg_y]]
point_labels = [1, 0]  # positive, negative
```

**장점**: SAM2 자체가 잎맥을 피하도록 유도
**단점**: negative point 위치 결정이 어려움. 매 프레임 재계산 필요

### 방안 5: 예상 영역 제한 (Expected Region Mask)

Kalman 예측 + baseline 크기로 "벌레가 있을 수 있는 영역" 마스크를 만들고, SAM2 출력과 교차(AND).

```python
expected_region = create_ellipse(pred_center, baseline_size * 1.5)
constrained_mask = sam2_mask & expected_region
```

**장점**: 물리적으로 불가능한 번짐을 원천 차단
**단점**: 벌레가 크게 자세를 바꿀 때 잘릴 수 있음

## 분석 요청

1. 위 5가지 방안 중 어떤 것이 가장 실용적이고 효과적인가?
2. 조합 전략 (예: 방안 1 + 방안 3)이 더 좋을까?
3. SAM2의 mask_input 파라미터가 번짐 방지에 실제로 효과가 있을까?
4. 임계값 조정(SH1 완화)만으로 충분할 수 있는 상황이 있는가?
5. 다른 접근법이 있는가?

## GPT 의견

# Claude에게 전달할 의견 — SAM2 잎맥 번짐(Vein Bleeding) 대응 (2026-02-07)

## 0) 핵심 진단 (왜 번지는가)
- 현재 SAM2 prompt는 **box + (Kalman pred) 단일 positive point**.
- 벌레가 **정지/저속**일 때 Kalman pred는 안정적이지만,
  ROI 내에 **고대비 잎맥(선형 텍스처)**가 있으면 SAM2가 “길쭉한 경계”를 벌레 경계로 혼동해 마스크가 잎맥으로 흘러감.
- 이때 단순히 SH1로 “거부 → predict-only”를 하면,
  - 드리프트가 누적되고(비록 K1로 감쇠해도),
  - ROI 확장/재획득 과정에서 더 큰 오염 마스크가 들어올 수 있음.
=> 따라서 “Reject만” 강화하는 게 아니라, **우선 마스크를 정리(clean)해서 살리는 단계**가 필요함.

---

## 1) 5가지 방안 평가 (실용성/위험도 기준)

### 방안 1: Connected Component Filtering (CCF)  ✅ 1순위(가성비 최고)
- 번짐이 “벌레 + 잎맥”이 함께 잡힌 상황에서, **pred center에 가까운 컴포넌트만 남기기**는 가장 싸고 효과적인 1차 처치.
- 장점: 구현/속도/해석(디버깅)이 좋음. 실패해도 오염을 줄임.
- 단점: 벌레-잎맥이 **완전히 연결**되면 분리 불가.

### 방안 2: Erosion + CCF + Dilate  ✅ 보조(조건부)
- “얇게 연결된 잎맥”이면 erosion이 연결을 끊어 CCF가 잘 작동함.
- 단점: **작은 벌레**에서는 erosion으로 벌레가 사라질 수 있음.
- 결론: 항상 적용이 아니라, **번짐 감지 시에만** 작은 커널/적은 iter로 제한적으로.

### 방안 3: SAM2 mask_input (last-good logits)  ✅ 2순위(효과 가능성 큼, 안전장치 필수)
- 시간적 일관성을 강하게 부여해 “잎맥으로 새는” 방향을 줄일 가능성이 큼.
- 단점: last-good이 이미 오염이면 오염을 전파.
- 결론: **“last_good only” + “오염 탐지 시에는 사용 금지”**가 전제.
  - 예: shape_score/temporal_score/border_touch 기준 통과한 프레임만 last_good로 인정

### 방안 4: Negative Point Prompt  ⚠️ 3순위(좋지만 구현 난이도 큼)
- 효과는 있을 수 있으나, **negative point 위치 산정이 핵심 난제**.
- 잘못 찍으면 실제 벌레를 배제해 추적이 즉시 붕괴할 수 있음.
- 결론: 초기 버전에서는 보류 권장.
  - 다만 “번짐 delta(현재-이전)”에서 멀리 튄 영역 중심을 neg로 찍는 시도는 가능.

### 방안 5: Expected Region Constraint (AND)  ✅ 1~2순위(강력한 안전장치)
- Kalman pred 기반 “가능 영역”을 만들고 SAM2 mask를 제한하면,
  **물리적으로 불가능한 잎맥 확산을 원천 차단**할 수 있음.
- 단점: 벌레 자세가 크게 바뀌거나 급이동 직후엔 잘릴 수 있음.
- 결론: 항상 강하게 AND 하기보다,
  - “번짐 징후(면적비/shape_score/border_touch) 있을 때만” 적용하거나
  - ellipse 크기를 넉넉히(1.5x~2.0x) 두고, 상태별로 조절하는 방식이 안전.

---

## 2) 추천 조합 전략 (현 토글 구조에 맞춘 현실적인 플랜)

### 추천 v1 (가장 실용적/안전) : [1] + [5] + (선택적으로 [2])
1) **번짐 감지(Trigger)**:
   - 예: border_touch↑, mask_roi_area_ratio↑, shape_score↓, thickness_p90↑, temporal_score↓
2) Trigger 발생 시:
   - (A) **CCF로 pred 근처 컴포넌트 유지**
   - (B) 여전히 크거나 연결된 번짐이면 **Erode(약하게) → CCF → Dilate**
   - (C) 마지막으로 **Expected Region AND** (과도 확산 차단)
3) 정리된 mask로 ShapeStats 재계산 후,
   - 충분히 회복되면 SAM2 채택/캐시 진행
   - 회복 실패면 “reject”하되, **prompt/bbox 오염은 HOLD**하고 REACQUIRE로 넘김

### 추천 v2 (추가 향상) : v1 + [3] mask_input(last_good)
- v1을 먼저 넣고 안정화한 뒤,
- 번짐이 반복되는 트랙에서만 mask_input을 켜는 방식이 안전.
- 반드시:
  - last_good_mask_logits는 “좋은 프레임”에서만 갱신
  - 번짐 트리거가 뜬 프레임엔 mask_input 사용 금지(오염 전파 방지)

---

## 3) SH1(Shape Gate) 정책 수정 제안 (중요)
현재 SH1은 “shape_score < 0.6 → 전체 거부(PRED)”라서,
번짐 상황에서 **복구 시도 없이 드리프트 루프로 들어가기 쉬움**.

권장 정책(순서):
1) shape_score < 0.6 이면 즉시 reject가 아니라,
2) 먼저 **마스크 정리(clean: CCF/erosion/expected region)** 후 재평가
3) 정리 후에도 shape_score < 0.6 이면 그때 reject
4) reject 시에도:
   - bbox/prompt 업데이트는 HOLD
   - last_good 캐시는 유지(오염 프레임 cache 차단)

=> “거부”는 최종 수단으로 밀고, **살릴 수 있으면 살리는 단계가 먼저**.

---

## 4) 추가 아이디어 (5개 방안 밖에서, 비용 대비 효과 좋은 것)
### A) 정지/저속일 때 box를 ‘축소’ (vein 혼동 감소)
- 번짐은 ROI/box가 넓을수록 잎맥을 포함할 확률이 커짐.
- 속도(=Kalman |v|)가 낮으면 box_expansion을 1.0보다 작게(0.8 등) 해서
  “잎맥 포함” 자체를 줄일 수 있음.
- 급이동/REACQUIRE에서만 box 확장.

### B) positive point를 1개 → 2~3개로 (이전 good 마스크 기반)
- 단일 pred point만으로는 잎맥과 벌레를 구분하기 어려움.
- last_good_mask가 있을 때:
  - center + (PCA endpoints 근처 1~2개) 같은 다중 positive로 “벌레 형태”를 더 강하게 앵커링 가능.
- negative point보다 위험이 낮음.

---

## 5) 구현 우선순위 제안
- P0: **Mask Clean-up 단계(v1: CCF + optional erosion + expected region)** 추가
- P1: SH1을 “reject 전에 clean 재평가” 구조로 변경
- P2: (선택) last_good mask_input 도입 (오염 방지 조건 포함)
- P3: (선택) low-speed box shrink + multi-positive points

---

## 6) 결론 (질문에 대한 답)
1) 가장 실용적/효과적: **방안 1(CCF) + 방안 5(Expected Region)** 조합이 1순위
2) 조합이 단일보다 좋음: 특히 v1(1+5(+2))는 실패 시에도 오염을 줄여 재획득이 쉬움
3) mask_input 효과 가능성: 있음. 단 **last_good only + 오염 탐지 시 금지** 조건이 필수
4) 임계값(SH1) 완화만으로 충분?: 가능성 낮음. 번짐은 “판단 임계값”보다 “마스크 구조 자체”가 깨지는 문제라
   완화하면 오히려 번짐을 채택해 드리프트/오염 루프를 키울 위험이 큼
5) 다른 접근: low-speed box shrink, multi-positive points(이전 good 마스크 기반) 같은 prompt 개선이 비용 대비 좋음


---

## Claude 분석 (GPT 의견 반영 후 수정)

### GPT 의견에 대한 동의/수정

**전면 동의:**
- CCF가 1순위 — 구현 비용 대비 효과 최고
- SH1 "즉시 거부" → "clean 먼저, 그래도 안 되면 거부" 구조 변경 필수
- mask_input은 v2 (v1 안정화 후). 오염 전파 방지 조건 필수
- 임계값 완화만으로 불충분 — 마스크 구조 자체가 깨지는 문제

**수정 (GPT 의견 반영):**
- 기존 Claude 분석: CCF + mask_input → **수정: CCF + Expected Region** (v1)
- GPT의 Expected Region(방안 5) 평가가 설득력 있음: 물리적으로 불가능한 확산 차단
- mask_input은 v2로 이동 (v1 안정화 후)

**GPT 추가 아이디어 채택:**
- **저속 시 box 축소**: 번짐 원인(넓은 box에 잎맥 포함)을 줄이는 근본적 접근. 구현 간단
- **다중 positive point**: last_good의 PCA endpoints를 추가 prompt로 사용. negative보다 안전

### 최종 구현 계획

**Phase 1 (즉시): Mask Cleanup Pipeline**
```
SAM2 mask 출력
  → ShapeStats 1차 분석
  → shape_score < 0.8?  (번짐 의심)
    YES → CCF: pred 근처 component만 유지
         → 면적 < baseline × 0.3? → Erode+CCF+Dilate 시도
         → Expected Region AND (baseline × 1.5 ellipse)
         → ShapeStats 재분석
         → shape_score >= 0.6? → 정리된 mask로 fusion 진행
         → 여전히 < 0.6? → reject (predict-only)
    NO  → 정상 mask로 fusion 진행
```

**Phase 2 (Phase 1 안정화 후): SAM2 prompt 개선**
- mask_input: last_good mask logits 전달 (좋은 프레임에서만 갱신)
- multi-positive: center + PCA endpoints (last_good 기반)
- low-speed box shrink: Kalman |v| 낮으면 box_expansion 0.8

### 구현 위치

| 단계 | 파일 | 변경 내용 |
|------|------|----------|
| CCF + Erosion | `pipeline/runner.py` (c-2 이후) | shape_score 낮으면 mask cleanup 호출 |
| Expected Region | `pipeline/runner.py` | baseline 기반 ellipse AND |
| SH1 구조 변경 | `qa/fusion.py` | reject 전 clean mask 재평가 |
| mask_input | `sensors/sam2_sensor.py` | predict()에 mask_input 추가 |
| box shrink | `sensors/sam2_sensor.py` | Kalman 속도 기반 box 조절 |

---

## 합의 사항

### Claude + GPT 합의

1. **핵심 전략**: "거부보다 정리(clean) 우선" — SH1의 즉시 거부를 clean-then-reject로 변경
2. **v1 구현**: CCF + (조건부 Erosion) + Expected Region → ShapeStats 재분석 → 채택/거부
3. **v2 구현**: mask_input (last_good only, 오염 시 금지) + multi-positive points
4. **prompt 최적화**: 저속 시 box 축소, PCA endpoints 기반 다중 positive
5. **SH1 임계값 완화는 보조적**: clean 단계가 효과적이면 임계값 변경 불필요할 수 있음
6. **P2 (state_roi_expansion) ON 유지**: 가장 안정적인 추적 개선 확인됨

### 구현 우선순위
- **P0**: Mask Cleanup (CCF + Expected Region) + SH1 구조 변경
- **P1**: mask_input 도입 (오염 방지 조건 포함)
- **P2**: prompt 개선 (box shrink + multi-positive)
