# 2026-02-07 GPT Discussion — SAM2 잎맥 번짐 문제 대응 전략

## 배경

### 현재 파이프라인 (per-track, per-frame)
```
Kalman predict → ROI crop → 3 Sensors (SAM2, Template, KLT)
  → ShapeStats 분석 → QA Fusion → KF update → State Machine → bbox/template 갱신
```

- **SAM2**: 주 센서. ROI 내에서 box+point prompt → segmentation mask → centroid 추출
- **Template (TPL)**: Gray+Sobel NCC 매칭. SAM2 교차검증용 보조 센서
- **KLT**: 광학 흐름 기반 feature tracking. SAM2 교차검증용 보조 센서
- **QA Fusion**: SAM2 결과를 TPL/KLT와 교차검증하여 채택/거부 결정
- **ShapeStats**: skeleton 기반 마스크 형태 분석 (tube_fit, width_cv 등)

### 16개 Feature Toggle 상세 설명

각 토글은 `config.yaml`의 `toggles:` 섹션에서 ON/OFF.
**기본값(baseline)**: 아래 표의 "기본" 열 참조.

#### Fusion 토글 (qa/fusion.py)

| ID | 이름 | 기본 | ON 동작 | OFF 동작 |
|----|------|------|---------|----------|
| F1 | `active_reacquire_split` | **ON** | ACTIVE 모드(엄격: consensus 필수)와 REACQUIRE 모드(관대: consensus 없어도 채택)를 분리. ACTIVE에서 consensus 실패 시 거부 | 단일 경로. ACTIVE/REACQUIRE 구분 없이 동일 조건으로 SAM2 채택 |
| F2 | `soft_pred_penalty` | OFF | SAM2↔predict 거리가 임계값 초과해도 즉시 거부하지 않고, quality 감점 + measurement_R 증가로 소프트 처리 | **하드 게이트**: 거리 > 임계값이면 SAM2 즉시 거부 (predict-only) |
| F3 | `strict_consensus` | **ON** | TPL/KLT가 None(측정 실패)이면 합의 실패 처리. **센서가 존재하고** SAM2와 가까워야 합의 인정 | None이면 합의 통과 처리. 센서 결과가 없으면 "반대하지 않았으므로" 합의로 간주 |
| F4 | `area_continuity_penalty` | OFF | 이전 프레임 대비 면적 급변 시 quality 감점 (0.5배 미만 또는 2배 초과) | 면적 연속성 검사 안 함 |
| F5 | `reacquire_active_recovery` | **ON** | UNCERTAIN/OCCLUDED에서 consensus + quality ≥ 0.8 충족 시 ACTIVE로 복귀 허용 | REACQUIRE 모드에서는 항상 UNCERTAIN hint만 반환 (ACTIVE 직접 복귀 불가) |

#### Pipeline / ROI 토글 (pipeline/runner.py)

| ID | 이름 | 기본 | ON 동작 | OFF 동작 |
|----|------|------|---------|----------|
| P1 | `speed_roi_expansion` | OFF | Kalman 속도 > 임계값이면 ROI 1.5x 확장 (빠른 이동 대응) | ROI 크기 고정 (base_size 기반) |
| P2 | `state_roi_expansion` | OFF | UNCERTAIN/OCCLUDED 상태에서 ROI를 **1.25x 확장** → SAM2가 더 넓은 영역 탐색 | 상태 무관하게 ROI 크기 고정 |
| P3 | `expansion_cooldown` | OFF | ROI 확장 후 ACTIVE 복귀 시 5프레임 동안 서서히 축소 (히스테리시스) | 확장/축소 즉시 전환 |
| P4 | `sam2_bbox_sync` | OFF | SAM2 마스크의 bbox를 매 프레임 track.bbox에 동기화 (sensor_used와 무관) | sensor_used=="SAM2"일 때만 bbox 갱신 |
| P5 | `reacquire_box_expansion` | OFF | REACQUIRE 시 SAM2 box prompt를 ROI expansion 비율만큼 확장 | box prompt 크기 항상 seed_bbox 크기 고정 |

#### Sensor 토글

| ID | 이름 | 기본 | ON 동작 | OFF 동작 |
|----|------|------|---------|----------|
| S1 | `composite_mask_selection` | **ON** | SAM2 multi-mask 중 복합 점수(SAM2 score + pred 근접성 + 면적 일관성 + border_touch) 최고 마스크 선택 | argmax(SAM2 scores)로 단순 선택 |
| S2 | `template_update_gating` | **ON** | SAM2 quality ≥ 0.7일 때만 TPL 템플릿 갱신 (나쁜 프레임으로 템플릿 오염 방지) | 매 프레임 무조건 갱신 |
| S3 | `klt_divergence_reinit` | **ON** | KLT↔SAM2 거리 > 임계값이면 KLT feature points 재초기화 | KLT 발산해도 유지 |
| S4 | `sam2_mask_caching` | **ON** | QA 통과한 SAM2 결과(mask, center, area) 캐시. 다음 프레임 prev_area로 면적 연속성 검사에 사용 | 캐시 없음. prev_area=None → 면적 연속성 검사 불가 |

#### Shape / Kalman / State Machine

| ID | 이름 | 기본 | ON 동작 | OFF 동작 |
|----|------|------|---------|----------|
| SH1 | `shape_quality_gate` | **ON** | shape_score < 0.6: 전체 거부(predict-only). < 0.8: bbox HOLD + cache 차단 + quality 감점 | shape 분석 결과를 무시. 모든 SAM2 마스크 형태 무관하게 통과 |
| K1 | `velocity_decay_on_predict` | **ON** | predict-only (SAM2 거부) 시 Kalman 속도를 0.5x 감쇠 → 드리프트 억제 | 속도 감쇠 없음. predict-only 시 마지막 속도 유지 → 직선 드리프트 |
| SM1 | `occluded_to_uncertain_recovery` | OFF | OCCLUDED 상태에서 UNCERTAIN hint 받으면 UNCERTAIN으로 전환 (재획득 시도) | OCCLUDED에서 UNCERTAIN 복귀 불가. ACTIVE hint 필요 |

### A/B 테스트에서 가장 좋았던 설정

**P2_state_roi_ON** 테스트 시 실제 적용된 전체 토글 상태:
```
[ON ] F1  active_reacquire_split    ← ACTIVE/REACQUIRE 모드 분리
[OFF] F2  soft_pred_penalty          ← pred 거리 하드 게이트
[ON ] F3  strict_consensus           ← 엄격 consensus (None=불합의)
[OFF] F4  area_continuity_penalty
[ON ] F5  reacquire_active_recovery  ← REACQUIRE→ACTIVE 복귀 허용
[OFF] P1  speed_roi_expansion
[ON ] P2  state_roi_expansion        ← ★ 변경: UNCERTAIN/OCCLUDED에서 ROI 1.25x
[OFF] P3  expansion_cooldown
[OFF] P4  sam2_bbox_sync
[OFF] P5  reacquire_box_expansion
[ON ] S1  composite_mask_selection   ← 복합 점수 마스크 선택
[ON ] S2  template_update_gating     ← TPL 업데이트 품질 게이팅
[ON ] S3  klt_divergence_reinit      ← KLT 발산 재초기화
[ON ] S4  sam2_mask_caching          ← SAM2 결과 캐싱
[ON ] SH1 shape_quality_gate         ← shape 기반 마스크 거부
[ON ] K1  velocity_decay_on_predict  ← predict-only 속도 감쇠
[OFF] SM1 occluded_to_uncertain_recovery
```

**F3_strict_OFF** 테스트 시 차이점:
```
[OFF] F3  strict_consensus  ← ★ 변경: None=합의 통과 (TPL/KLT 없어도 SAM2 채택)
```
이 경우 TPL/KLT가 측정 실패하거나 발산해도 SAM2가 단독으로 채택됨.
→ SAM2가 정확하면 좋지만, SAM2가 번지면 교차검증 없이 번짐 수용.

### 육안 검증 결과 (P2_state_roi_ON / F3_strict_OFF)
이 조합이 **지금까지 가장 좋은 추적**:
- 초록 벌레: 첫 큰 움직임에 SAM2가 정확히 따라감 (기존엔 항상 놓침)
- 파란 벌레: 이전에 전혀 추적 안 되던 것이 초반 추적 성공 (돌파)
- 빨간 벌레: 안정적. 머리 1/4만 빠지고 몸통 3/4 추적

### 핵심 문제: SAM2 잎맥 번짐 (Vein Bleeding)

벌레가 제자리 맴돌 때 어두운 잎맥으로 SAM2 마스크 번짐:
```
정상 추적 → 정지/느린 움직임 → 잎맥으로 마스크 번짐 → 벌레가 ROI 밖 이탈 → 추적 실패
```

번짐 조건:
- 벌레 정지 또는 느린 움직임
- 근처에 어두운 잎맥 (높은 대비 경계)
- SAM2가 잎맥 텍스처를 벌레 경계와 혼동

## 논의 주제 — 번짐 대응 방안

### 현재 SAM2 prompt 전략
```python
# Box prompt: Kalman 예측 center + seed bbox 크기
box = [cx - half_w, cy - half_h, cx + half_w, cy + half_h]

# Point prompt: Kalman 예측 위치 1개 (positive)
point_coords = [[cx_roi, cy_roi]]
point_labels = [1]  # positive

# Mask input: 없음 (사용 안 함)
```

### 현재 품질 게이트 (SH1)
```python
# fusion.py
if shape_score < 0.6:
    # 전체 거부 → predict-only (OCCLUDED)
    return PRED

# runner.py
if shape_score < 0.8:
    # bbox HOLD + cache 차단 + quality 감점
```
**문제**: 거부만 하고 복구 시도가 없음. predict-only → 위치 드리프트 축적

### 방안 1: Connected Component Filtering (마스크 후처리)

번짐 감지 시 SAM2 마스크를 connected component로 분리, 예측 위치에 가장 가까운 컴포넌트만 유지.

```
[번짐 마스크]          [필터링 후]
 ██████████          ██████
 ████ ← 잎맥         (잎맥 제거)
 ██████████          ██████
```

**장점**: 번짐 부분만 제거하고 벌레 부분 보존 가능
**단점**: 벌레-잎맥이 완전히 연결되면 분리 불가
**구현**: SAM2 출력 직후, shape_score 검사 전에 적용

```python
# 번짐 감지 시
if shape_score < threshold:
    # 1) 마스크를 connected components로 분리
    # 2) pred center에 가장 가까운 component만 유지
    # 3) 너무 작으면 fallback
    cleaned_mask = keep_nearest_component(mask, pred_center)
    # re-analyze shape
```

### 방안 2: Morphological Erosion + Reconnect

마스크를 약간 침식(erode)하여 벌레-잎맥 사이의 얇은 연결을 끊은 후, 벌레 쪽만 유지.

```python
eroded = cv2.erode(mask, kernel_3x3, iterations=2)
# connected component에서 pred 근처 것만 유지
# 다시 dilate로 원래 크기 복원
```

**장점**: 얇은 연결 효과적으로 끊음
**단점**: 작은 벌레가 erosion으로 사라질 수 있음

### 방안 3: SAM2 mask_input 활용 (시간적 일관성)

SAM2 predict()에 이전 좋은 마스크를 mask_input으로 전달하여 시간 연속성 유도.

```python
masks, scores, _ = predictor.predict(
    box=box[None, :],
    point_coords=point_coords,
    point_labels=point_labels,
    mask_input=prev_good_mask_logits,  # <-- 새로 추가
    multimask_output=True,
)
```

**장점**: SAM2가 이전 프레임 마스크를 참조하여 자연스러운 연속성
**단점**: 이전 마스크가 이미 번져있으면 번짐 전파
**주의**: 캐시된 "마지막 좋은 마스크"만 사용해야 함

### 방안 4: Negative Point Prompt

번짐 감지 시, 잎맥 영역에 negative point를 추가하여 해당 영역 배제.

```python
# 번짐 영역의 중심을 negative point로
neg_point = find_bleed_center(current_mask, prev_good_mask)
point_coords = [[cx, cy], [neg_x, neg_y]]
point_labels = [1, 0]  # positive, negative
```

**장점**: SAM2 자체가 잎맥을 피하도록 유도
**단점**: negative point 위치 결정이 어려움. 매 프레임 재계산 필요

### 방안 5: 예상 영역 제한 (Expected Region Mask)

Kalman 예측 + baseline 크기로 "벌레가 있을 수 있는 영역" 마스크를 만들고, SAM2 출력과 교차(AND).

```python
expected_region = create_ellipse(pred_center, baseline_size * 1.5)
constrained_mask = sam2_mask & expected_region
```

**장점**: 물리적으로 불가능한 번짐을 원천 차단
**단점**: 벌레가 크게 자세를 바꿀 때 잘릴 수 있음

## 분석 요청

1. 위 5가지 방안 중 어떤 것이 가장 실용적이고 효과적인가?
2. 조합 전략 (예: 방안 1 + 방안 3)이 더 좋을까?
3. SAM2의 mask_input 파라미터가 번짐 방지에 실제로 효과가 있을까?
4. 임계값 조정(SH1 완화)만으로 충분할 수 있는 상황이 있는가?
5. 다른 접근법이 있는가?

## GPT 의견



---

## Claude 분석

### 추천 전략: 방안 1 (CC 필터링) + 방안 3 (mask_input)

**1단계 (즉시 구현 가능): Connected Component Filtering**
- shape_score가 낮을 때만 적용 (정상 프레임에는 영향 없음)
- SAM2 출력 직후, shape 분석 전에 적용
- 구현이 간단하고 부작용이 적음
- OpenCV의 `connectedComponentsWithStats`로 바로 가능

**2단계 (추가 검증 후): mask_input 활용**
- SAM2에 시간적 힌트를 주어 번짐 자체를 억제
- `cache_good_result()`에 이미 마지막 좋은 마스크가 저장되어 있음
- 다만 SAM2 mask_input의 실제 효과를 검증해야 함

**SH1 임계값 완화는 보조적**:
- 현재 0.8/0.6 → 0.7/0.5 정도로 완화하되, CC 필터링과 조합
- CC 필터링이 마스크를 정제하면 shape_score가 자연스럽게 올라갈 것

---

## 합의 사항


