# GPT Discussion 2026-01-30

# ROI 기반 SAM2 추적 디버깅 정리 (대화 발췌)

> 요청: 아래 내용은 사용자가 지정한 구간(“핵심부터 말하면…” 단락)부터 이후 질문/답변을 **요약 없이 가능한 그대로** 붙여넣기 용도로 정리한 것입니다.

---

## 1) (Assistant) 원인 진단 핵심 단락

핵심부터 말하면, 지금 네 증상(ROI 안에 벌레가 있는데도 SAM2가 엉뚱한 데를 잡거나, 한 번 놓치면 ROI가 못 따라가다가 **벌레가 ROI 위로 다시 올라오면** 그제서야 다시 잡는 현상)은 **“SAM2가 ROI라서 못 쓰는 구조적 한계”라기보다, 코드 설계(게이팅 + 프롬프트 박스 관리 + 멀티마스크 선택)가 ‘재획득(reacquire)’을 거의 불가능하게 만드는 구조** 때문에 생기는 게 맞아.

내가 업로드한 zip(`worm_detection-main (1).zip`)의 실제 코드 기준으로, 원인을 3개로 압축하면 이거야.

---

## 2) (User) 질문: 서로 다른 방향을 가리킬 때 점수 높은 방향으로 움직이도록 설계되어 있나?

벌레를 추적할 때 만약 평가하는 요소가 전혀 다른 방향을 가리키고 있을 경우 우리는 그 점수에 따라 점수가 높은 방향으로 움직이도록 코드가 설계되어있지?

---

## 3) (Assistant) 답변: “점수 최대”가 아니라 규칙+우선순위+게이트 기반 채택

아니. **지금 코드 구조는 “점수가 높은 방향으로 이동”하는 방식이 아니라, `규칙 + 우선순위 + 거리 게이트`로 한 센서를 ‘채택’하는 방식**이야.

네 코드(`qa/fusion.py`) 기준으로 실제 동작은 이렇게 고정돼 있어:

## 1) 서로 다른 방향을 가리키면 “점수 비교”가 아니라 “통과/탈락”으로 결정됨

### 우선순위가 박혀 있음
1) **SAM2** (조건 통과하면 무조건 채택)
2) **TPL** (SAM2가 탈락했을 때만, 조건 통과하면 채택)
3) **KLT** (TPL도 안 되면, 조건 통과하면 채택)
4) **PRED-only** (모두 탈락)

즉, **어느 쪽 “점수(confidence)”가 높든**, 그 센서가 해당 케이스에서 먼저 평가되고 조건만 통과하면 그대로 그쪽으로 감.

---

## 2) “점수(confidence)가 높은 쪽으로 간다”가 아닌 이유 (코드상 확정)

### (A) SAM2는 confidence가 낮아도 조건만 맞으면 무조건 채택
SAM2 채택 조건은:
- `pred_ok`: SAM2 center가 Kalman 예측점(pred_center) 근처
- `tpl_ok`: SAM2와 TPL이 서로 근처(또는 TPL이 None이면 면제)
- `border_ok`: border_touch <= threshold

여기서 **confidence는 채택 여부에 영향을 안 줌.**
(채택 후 `quality_score`로 기록만 함)

### (B) TPL vs KLT도 점수로 경쟁하지 않음
SAM2가 탈락하면:
- TPL이 pred 근처면 **TPL 채택**
- 아니면 KLT가 pred 근처면 **KLT 채택**

여기서도 **TPL confidence가 KLT보다 낮아도** “TPL이 먼저 체크되므로” TPL이 조건만 통과하면 TPL이 이김.

---

## 3) “서로 전혀 다른 방향”을 가리킬 때 실제로 무슨 일이 생기나

- **SAM2가 pred 근처 + TPL과도 어느 정도 일치 + border_touch 낮음**이면  
  → **SAM2가 무조건 채택** (점수 비교 없음)

- SAM2가 pred에서 멀거나 / TPL과 멀거나 / border_touch가 크면  
  → SAM2는 탈락  
  → 그 다음 TPL이 pred 근처면 TPL 채택, 아니면 KLT, 아니면 PRED-only

즉, “서로 다른 방향이면 점수 높은 쪽으로 간다”가 아니라  
**‘누가 먼저 검사되고, 하드 조건을 통과하느냐’**로 결정돼.

---

## 4) 네가 의도한 게 “점수 기반으로 더 그럴듯한 쪽으로 이동”이라면
지금 구조는 그 목적에 안 맞아. 바꾸려면 최소 한 가지는 해야 해:

- **센서 후보들을 모두 모아서**  
  `(confidence, pred_dist, agreement(TPL/KLT), border_touch)` 같은 특징으로 **스코어를 만들고, 최고 스코어를 채택**  
- 또는 **가중 평균/혼합 업데이트**(단, 드리프트 방지용 게이트는 유지)

원하면 네 현재 `fusion.py`를 그대로 두고도, “충돌 시 점수 기반으로 선택”하는 형태로 **딱 필요한 부분만 수정한 패치**를 바로 제시할게.

---

## 4) (User) 분기 ROI 제안: 양쪽 ROI에서 같은 id를 추적 후 승자만 살리기

내가 그 말을 하는 이유가 아까 디버깅하는 중 나머지 예측은 잘못된 방향으로 향하고 하나의 정보만 제대로 된 방향으로 향했는데 무시당하는 것을 봤어. 이렇게 하나의 조건만 제대로 분석하는 경우에 대한 방어로 추적 ROI를 쪼개어 일시적으로 양쪽 모두에서 동일한 id의 벌레 추적을 시도한 후,  제대로 추적되는 것으로 분석되는 ROI만 살리고 나머지쪽의 추적을 죽이는 방식에 대해서는 어떻게 생각해? 리소스를 차지하는 것에 비해 효과가 낮을까?

---

## 5) (Assistant) 답변: 조건부 dual-hypothesis는 효과 큼, 상시 분기는 비효율

아이디어 자체는 “효과가 낮을까?”가 아니라, **지금 네 파이프라인의 약점을 정면으로 찌르는 방어책**이라서 *조건만 잘 걸면* 효과가 큽니다. 다만 **아무 때나 항상 2개 ROI로 복제 추적**을 하면 리소스 대비 효율이 급격히 떨어지고, 구현을 잘못하면 **ID 스왑/드리프트를 오히려 고착**시키는 함정도 있어요.

정리하면:

- ✅ **조건부(불확실/충돌 상황에서만)** “ROI 분기(dual-hypothesis)”는 강력한 방어.
- ❌ **상시 분기**는 비용이 너무 크고, 특히 SAM2를 ROI마다 돌리면 프레임당 비용이 2배 이상 튈 가능성이 큼.

---

## 왜 이 방식이 맞는 방향인가 (네가 본 “한 센서만 맞는데 무시” 문제의 본질)

지금 구조는 “점수 최대”가 아니라 **규칙 + 우선순위 + 게이트**로 채택 센서를 결정해. 그래서

- 다수가 틀린 방향으로 *서로 합의*하면 (또는 pred 근처면)  
  → 그게 “안전한 답”으로 채택됨
- 한 센서만 맞는데 **pred 거리/합의 조건**에 걸리면  
  → 그 센서는 “구조적으로” 기회가 없음

이 상황에서는 “한 번 놓치면 재획득이 어려움”이 나오고, 네가 본 현상이 정확히 그거야.

분기 ROI는 그 구조를 “한 번에” 해결하는 방법 중 하나다.  
즉 **현재 게이트가 틀린 가설을 고정시키는 순간**, 다른 가설(맞는 방향)을 “죽지 않게” 유지하는 거.

---

## ROI 분기(dual ROI 추적) 방식의 장점

### 1) 재획득(reacquire)에 강함
벌레가 실제로 ROI 밖으로 빠져나가거나, box prompt가 틀어져서 SAM2가 엉뚱한 걸 잡기 시작했을 때,
- 기존 가설은 pred 근처에서 계속 맴돌고(틀린데 안정적으로 보임)
- 다른 가설은 “진짜 위치”를 잡아서 신뢰도가 올라감

이러면 “벌레가 ROI로 다시 들어올 때만 회복” 같은 패턴을 끊을 수 있어.

### 2) 센서 하나만 맞을 때 “살아남는 통로” 제공
한 센서만 맞는 경우가 실전에서 생각보다 많아.  
특히 SAM2가 ROI 경계/부분 마스크로 흔들릴 때 KLT만 맞는 경우, 또는 반대로 KLT가 망가지고 SAM2만 맞는 경우.

분기 상태에서는 **맞는 센서가 있는 가설이 살아남고**, 나머지는 죽여버릴 수 있음.

---

## 비용/효율 관점: 상시 분기 vs 조건부 분기

### 상시 분기: 비추
- ROI 2개면 센서 계산이 거의 2배.
- 특히 네 구현이 “ROI crop → SAM2 set_image → predict” 구조면, **SAM2가 가장 무거운 비용**이라 바로 체감됨.
- 트랙 수가 3마리면 2배 분기 시 사실상 6개 트랙을 돌리는 셈이라, 프레임레이트가 확 떨어질 확률이 큼.

### 조건부 분기: 강추
아래 조건 중 하나일 때만 **짧은 기간(예: 10~30프레임)만** 분기해서 승자를 고르고 종료.

**트리거 추천**
- `UNCERTAIN`이 연속 N프레임(예: 5~10)
- `SAM2` 결과가 연속으로 거부됨(거리 게이트/ border_touch)
- 센서 간 불일치가 큼(예: SAM2 vs KLT 거리 > th)
- bbox 수축/경계 접촉이 반복(border_touch high 3회 이상)

이렇게 하면 “평상시엔 1배”, 문제 구간에서만 “잠깐 2배”라서 효율이 좋아져.

---

## 구현할 때의 핵심 설계: “분기 2개만 + 조기 종료 + 스코어링 명확”

### 1) 가설(hypothesis) 2개만 유지
- H0: 기존 pred 중심 기반 ROI (현재 방식)
- H1: “재획득 후보 ROI”
  - 후보 생성 방식 예:
    - pred 속도 방향으로 +Δ 이동한 ROI
    - 반대 방향으로 -Δ 이동한 ROI
    - 또는 bbox 중심 ±(ROI/4) 정도 shift
    - 또는 SAM2가 마지막으로 성공했던 center 주변 확장 ROI

※ 여기서 “ROI를 쪼개어 양쪽”이라는 표현은 좋지만, 실제로는 “좌/우”보다 **pred/반pred + 주변 shift**가 훨씬 일반적으로 잘 먹힘.

### 2) 각 가설은 최소 상태만 복제
가설마다 완전 복제하면 리소스와 버그가 늘어.

- 반드시 분리해야 하는 것:
  - KF state(x,y,vx,vy)
  - bbox / center
- 가능하면 분리해야 하는 것(하지만 비용 큼):
  - template (업데이트는 승자만)
  - KLT points (재시드는 승자만)

**추천 현실안**
- 분기 중에는 template/klt 업데이트 금지
- 측정만 하고, 승자 결정 후 승자에게만 상태/업데이트 반영  
→ 드리프트 고착을 막고 비용도 줄어.

### 3) “승자”를 고르는 스코어는 단일 점수로 단순하게
너의 목표는 “맞는 놈 살리고 나머지 죽이기”지, 복잡한 베이지안 모델링이 아니야.

스코어 예시(단순/강력):
- SAM2가 있으면:
  - + w1 * sam2_conf
  - - w2 * border_touch
  - - w3 * |area - expected_area| / expected_area
  - - w4 * dist_to_prev (너무 순간이동이면 감점)
- SAM2가 없으면:
  - + w5 * tpl_ncc
  - + w6 * klt_inlier_ratio
  - - w7 * dist_to_pred (너무 멀면 감점)

그리고 **2~3프레임 연속으로 스코어가 더 좋은 가설을 승자로 확정**하고 나머지 kill.  
(1프레임만 보고 결정하면 노이즈로 잘못 고를 수 있음)

---

## 중요한 경고: “두 ROI에서 같은 id를 동시에 추적”은 ID 스왑 위험을 키울 수도 있음
특히 가까운 개체가 있을 때, 두 가설이 서로 다른 개체를 잡아도 “같은 id”로 경쟁하게 되면,
- 잠깐 스코어가 높게 나온 쪽으로 id가 넘어가며 스왑이 발생할 수 있어.

그래서 분기 모드에서는 **타 트랙과의 배타성/거리 제약**을 같이 넣는 게 좋다.
- 다른 트랙의 center와 너무 가까운 가설은 감점(또는 금지)
- 다른 트랙의 마스크/ bbox와 IoU가 높으면 감점

이거 없으면 “맞는 ROI를 고른다”가 아니라 “옆 벌레를 낚아채서 살아남는다”가 될 수 있음.

---

## 비용 대비 효과를 더 올리는 “저렴한 대안”도 있음
ROI를 2개로 완전 복제하기 전에, 더 싸게 할 수 있는 재획득 단계가 있어.

### 대안 1) “fast proposal → expensive refine”
1) 여러 후보 ROI를 만든다(예: 3~5개 shift)
2) 후보들에 대해 **템플릿 매칭만**(가볍게) 돌려 top-1 또는 top-2 선택
3) 선택된 ROI에만 SAM2 실행

이러면 SAM2 호출이 2배로 늘지 않고, 대부분 1회로 유지됨.

### 대안 2) “확장 ROI 재획득”
불확실할 때 ROI를 키우는 것만으로도 회복이 크게 늘어.
- UNCERTAIN/OCCLUDED면 ROI를 1.5~2배
- 대신 SAM2는 다운스케일해서 실행(ROI만 줄이기보다 더 효과적일 때가 많음)

---

## 내 결론(냉정하게)
- 네가 제안한 “분기 ROI로 같은 id를 양쪽에서 잠깐 추적 후 승자만 살리기”는 **조건부로만 쓰면 효율 대비 효과가 높다.**
- 특히 네 시스템이 지금처럼 **게이트 때문에 재획득이 막히는 구조**라면, 분기는 “정답 루트가 무시되는 문제”를 구조적으로 해결한다.
- 다만 **상시 분기**는 리소스 낭비가 크고, SAM2가 무거운 이상 체감 성능이 크게 떨어질 가능성이 높다.
- 구현은 “2가설, 짧게(10~30프레임), 업데이트는 승자만, 배타성 감점 포함”이 가장 안전하다.

원하면, 네 현재 코드 구조(Track, RoiManager, Fusion)에 맞춰서
- `TrackHypothesis` 최소 구조체
- 분기 트리거 조건
- 스코어 함수
- 승자 확정 로직(연속 K프레임)
이걸 **바로 붙여넣을 수 있는 형태의 설계/코드 패치**로 구체화해줄게.

---

## 6) (User) 분기점이 잘 작동하려면 각 추적 상태 표기가 정확해야 하는데, 부분 마스크도 정상으로 표기되는 문제

분기점에 대한 방식이 잘 작동하려면 어쨌든 순간순간의 sam2나 TPL, KLT 등의 추적 상태가 정확히 표기되어야하잖아 (분기점이 생겼다는 것 자체가 해당 추적들이 잠시 흔들렸다고 보는 것이지만, 결국에는 안정화되어야 하는 거잖아). 추적중인 영상을 보면 벌레의 일부분만을 추적중인 sam2가 방향과 pred가 일치한다는 이유로 정상 작동중이라 표기되는 경우가 대부분이던데, 내가 보기엔 sam2가 정확히 벌레를 포착하지 못한 것으로 보였거든, 실제로 벌레가 움직이는 것에 즉각적으로 추적이 이어지지 못하는 경우도 많았고. 이런 부분에 대해서 코드를 기반으로 분석해줄래?

---

## 7) (Assistant) 답변: ACTIVE 표기의 의미가 빈약하고 “부분 마스크”를 정상으로 오인하는 구조

맞아. **지금 코드 기준으로 “SAM2가 벌레 ‘일부분만’ 잡고 있는데도 ACTIVE / SAM2로 정상 표기”되는 건 충분히 일어날 수 있고**, 네가 본 현상은 “모델이 못해서”라기보다 **QA(채택 조건)와 프롬프트(bbox) 갱신 방식이 ‘부분 마스크’를 정상으로 오인하도록 설계돼 있어서** 생긴다.

아래는 네 zip 코드 기준으로, 왜 그런지 “구조적으로” 딱 짚어서 설명할게.

---

## 1) 지금 “정상(SAM2, ACTIVE)”의 의미가 너무 빈약함

### (A) SAM2 결과의 confidence가 사실상 “경계에 안 닿으면 1.0에 가까움”
`sensors/sam2_sensor.py`에서:

- `confidence = 1.0 - border_touch`
- `border_touch`는 **마스크 픽셀 중 ROI 가장자리(1~2px) 닿는 비율**

즉, **벌레의 20%만 잡아도** 그 20%가 ROI 중앙에 있으면 `border_touch`는 낮고 confidence는 높아져.

> “벌레 전체를 잡았는지”는 이 confidence에 전혀 반영되지 않는다.

### (B) Fusion에서 SAM2 채택 조건이 “전체 포착”을 검사하지 않음
`qa/fusion.py`의 Case A(SAM2 채택):

- `pred_ok`: SAM2 center가 Kalman pred 근처
- `tpl_ok`: (TPL이 있으면) SAM2 center와 TPL center가 근처
- `border_ok`: border_touch <= 0.3

여기에도 **면적(area), bbox 크기, 마스크 IoU, 길쭉함, 형태 연속성** 같은 “벌레인지/부분인지”를 판별하는 정보가 전혀 없다.

결론:  
**‘부분 마스크’가 pred 근처에만 있으면 그대로 “ACTIVE [SAM2]”가 된다.**

---

## 2) 더 심각한 부분: “잘못된 SAM2라도 pred와 일치하면 계속 정상으로 굳는 자기강화 루프”

네가 말한 “즉각적으로 벌레 움직임을 못 따라가는데도 정상 표기”는 여기서 나온다.

1) 어떤 프레임에서 SAM2가 벌레가 아니라 **잎의 비슷한 텍스처/그림자**를 잡음  
2) 그 마스크 중심이 우연히 pred 근처라 `pred_ok` 통과 → **SAM2 채택**  
3) 채택되면 `do_kalman_update=True`로 KF가 그 잘못된 중심으로 업데이트됨  
4) 다음 프레임에서 pred 자체가 이미 틀린 곳을 가리킴  
5) 이후엔 “틀린 pred 근처에서만 SAM2를 채택”하니, **맞는 SAM2가 진짜 벌레를 잡아도 pred에서 멀면 거부**됨  
6) 결과적으로 “틀린데 안정적인” 상태로 오래 유지됨(표시는 ACTIVE)

이게 네가 본 “다른 센서는 맞는 방향인데 무시당함”의 대표적인 메커니즘이야.  
지금 설계는 **재획득(reacquire)**에 매우 약하다.

---

## 3) ROI에서 특히 심해지는 이유: 프롬프트 박스(bbox) 관리가 “부분 마스크 → 박스 수축”으로 무너짐

`Sam2Sensor`는 box prompt를 `track.bbox`로 만든다. 그런데 `runner.py`에서 bbox 갱신은 이렇게 돼있어:

- **SAM2가 채택되었을 때만** `tr.bbox = full_bbox`로 업데이트

문제는:

1) SAM2가 벌레의 일부만 잡으면 → `bbox_roi`가 작아짐  
2) 그 작은 bbox가 `tr.bbox`로 저장됨  
3) 다음 프레임 SAM2 box prompt가 더 작아져서 **더 작은 일부만 계속 잡게 됨**  
4) 머리/꼬리 잘린 채로 “정상”처럼 굳어짐

또 SAM2가 한 번 거부되면 bbox가 갱신되지 않아서, **옛 bbox로 계속 프롬프트를 넣는** 상황이 생긴다.  
이게 네 설명(“놓치고 ROI가 못 따라가다가, 벌레가 ROI 위로 다시 올라오면 다시 잡음”)과 정확히 맞는다.

---

## 4) ROI에서만 더 자주 터질 수 있는 “프롬프트 박스 좌표 안전성” 문제(코드 레벨)

`sensors/sam2_sensor.py` 박스 클램핑이 한쪽만 안전해:

```py
box[0] = max(0, box[0])
box[1] = max(0, box[1])
box[2] = min(w, box[2])
box[3] = min(h, box[3])


#------------------------------------------------------------------#
# “소프트 의심 + 조건부 재획득” 설계 정리 (붙여넣기용)

## 핵심 결론
- 면적/형태 연속성 **게이트(옵션 A)**는 오탐을 **반드시** 만든다.  
  배속/웅크림/가림(occlusion)에서 “정상인데 급변”이 자주 발생하기 때문.
- 그렇다고 “안전한 방법은 없다”로 끝내면 안 되고, 현실적으로 가장 안전한 조합은:
  1) **하드 거부(게이트)**가 아니라 연속성 지표를 **‘증거(의심 신호)’**로만 쓰고  
  2) 의심일 때만 **재획득 메커니즘(분기/확장)**을 실행하는 것.

---

## 왜 “오탐 0으로 부분 마스크 차단”은 불가능한가
- **연속성 검사만으로 ‘부분 마스크’를 완벽히 막으면서 오탐이 0인 방법은 없다.**
- 이유: 관측치(마스크/면적/비율)만으로는
  - “진짜 형태 변화/가림(정상)”과
  - “잘못 잡은 부분 마스크(비정상)”
  를 구분 불가능한 케이스가 존재한다.

---

## 하지만 “오탐을 크게 늘리지 않으면서” 개선하는 안전한 설계는 있다
- 핵심은 **게이트로 차단(reject)**이 아니라  
  **의심 신호로 취급**하고 **그때만 재획득(reacquire)**을 실행하는 것.

---

# 1) 면적/형태 연속성 검사: 단독 ‘차단’은 위험, ‘증거’로는 유용

## 옵션 A(게이트 추가)가 위험한 이유
하드 게이트는 이렇게 망한다:
- 벌레가 웅크림/늘어남 → 면적/비율 급변(정상) → **SAM2 거부**
- 거부되면 파이프라인은 대부분
  - **PRED-only로 굳거나**
  - **ROI가 못 따라감**
- 즉, “부분 마스크 오염 방지” 대신 “정상 추적을 스스로 끊는” 오류를 만든다.

특히 이 시스템은 **거부 후 정답을 다시 찾는 단계가 약한 구조**라서, 게이트는 더 치명적임.

## 옵션 B(quality 페널티)는 훨씬 안전
중요 포인트:
- “급변 = 무조건 잘못”이 아니라, 급변은 **‘불확실’ 신호**로만 취급해야 함.

페널티를 주면:
- 잘못된 부분 마스크가 “완벽히 정상”으로 굳는 걸 줄이고
- 상태머신이 **UNCERTAIN/OCCLUDED**로 갈 확률을 올리고
- 그 상태에서 **분기/확장 같은 재획득 루틴**을 트리거할 수 있음

→ 현실적으로 오탐을 제일 덜 만드는 사용법.

---

# 2) “분기점 생성(dual hypothesis/ROI)”이 더 근본적인 이유

- 연속성 검사는 “거부”만 한다. **정답을 다시 찾지는 못한다.**
- 분기/확장은 “거부 이후의 행동”을 제공한다:

흐름:
1) 연속성/불일치가 생기면 → **의심 상태로 전이**
2) 그때만
   - ROI를 두 가설로 운영(dual ROI)하거나
   - ROI를 확장해서 재탐색
3) **승자 선택 후** 원래 트랙으로 합침

이건 “오류를 완전히 없애는” 게 아니라,
- 실수했을 때도 다시 돌아올 **회복력**을 올리는 방식이라 안정적임.
- 리소스도 상시가 아니라 **조건부로만** 하면 효율이 괜찮음.

---

# 3) “오류를 추가할 가능성이 없는 안전한 방법”이 있나?

정직하게 말하면:
- 없다(0-오탐 / 0-미탐 둘 다 만족하는 규칙은 불가능).  
  관측 가능한 정보가 제한되어 있고, 동일한 관측이 서로 다른 실제 상황(가림 vs 잘못된 부분 탐지)을 만들어낼 수 있기 때문.

하지만 “오류를 거의 추가하지 않는” 방향은 있다:

✅ **하드 게이트 대신 “소프트 의심” + “재획득 루틴”**

즉:
- 연속성 급변 → 즉시 reject 하지 말고
- **quality 감점 + UNCERTAIN 전이 조건 강화**
- 그리고 **UNCERTAIN에서만** 분기/확장 실행

→ “정상인 상황을 끊는” 오탐을 최소화하면서 “부분 마스크 고착”을 줄이는 조합.

---

# 4) 추천 조합(실전에서 안전한 설계)

## A. 연속성은 ‘단독 결정권’을 주지 말 것
아래 중 **2개 이상** 동시에 만족할 때만 “강한 의심”으로 간주:
- area 급감(예: < 0.5배)
- aspect 급변(예: ratio change 큰 값)
- mask IoU 급락(이전 good mask와 < 0.2)
- SAM2 후보들 사이에서 **pred 근처 후보가 score 최댓값이 아님**(=멀티마스크 선택 불안정)
- KLT/TPL과 center 불일치 증가

→ 이렇게 하면 웅크림/가림(정상 급변)에서 덜 걸린다.

## B. “강한 의심”이 생겼을 때만 재획득
재획득 옵션(비용/안전성 순):
1) **ROI 확장 + 멀티마스크 재선택** (가장 싸고 안전)
2) **fast proposal(TPL/KLT로 후보 ROI 뽑기) → top1~2에만 SAM2** (SAM2 호출 수 최소)
3) **dual ROI(2가설 병렬)** (가장 강력하지만 비용 큼 → 짧게만)

## C. 멀티마스크 선택 로직은 반드시 바꿔야 함(핵심)
- 지금처럼 `argmax(score)` 고정이면 ROI 안에서 엉뚱한 후보를 고르는 순간이 생김.
- `pred/prev 근접성 + 면적 일관성 + border_touch`를 같이 넣어 후보를 고르면
  “점수만 높아서 부분 마스크가 선택되는” 상황이 줄어든다.

---

## 최종 결론
- 면적/형태 연속성 **게이트(옵션 A)**: 오탐으로 트랙을 끊을 가능성이 커서 **비추천**
- 연속성 **페널티(옵션 B)**: 단독으론 부족하지만 ‘의심 신호’로 쓰면 **안전하고 유효**
- **분기/확장(재획득 루틴)**: “놓치면 못 돌아오는 구조”를 깨는 방법이라 **더 근본적**
- “부분 마스크를 완벽히 막으면서 오류를 추가하지 않는 방법”은 없음.  
  대신 **소프트 의심 + 조건부 재획득**이 오류 증가를 최소화하는 최선의 타협안.

---

## 다음 작업(패치 단위로 제공 가능)
원하면 코드 구조 기준으로 아래 4개를 “바로 붙여넣을 수 있는 패치”로 나눠서 제공 가능:
- 연속성 페널티 수식(과도한 감점 방지)
- UNCERTAIN 전이 조건
- ROI 확장/fast proposal/dual ROI 트리거 우선순위
- 멀티마스크 선택 함수 교체(핵심)
