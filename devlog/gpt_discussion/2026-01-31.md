# GPT 논의 - 2026-01-31

## 논의 주제: SAM2 마스크 정확 → QA 거부 문제

### 관찰된 현상

1. SAM2가 벌레의 큰 움직임을 정확히 추적 (마스크가 벌레 위치에 정확히 위치)
2. 그러나 bbox는 이전 위치에 머무르고 OCCLUDED 상태로 전환
3. Kalman 예측은 이동 방향을 잘 예측하지만 SAM2 결과가 반영되지 않음
4. 결과적으로 배경을 추적하기 시작

### 확인된 원인

**QA fusion의 `pred_ok` 하드 게이트** (`qa/fusion.py:111`)

```python
pred_ok = (d_pred <= dist_pred_th)  # dist_pred_th ≈ 65px
```

벌레가 65px 이상 움직이면:
1. SAM2가 정확한 위치를 찾아도
2. Kalman 예측과의 거리가 임계값 초과
3. `pred_ok = False` → SAM2 거부
4. Kalman 업데이트 안됨 → 악순환

---

## 해결 방안 후보

### 1. 임계값 완화
- `dist_pred_ratio`를 0.12 → 0.25 등으로 증가
- 장점: 간단
- 단점: 잘못된 SAM2도 수락할 수 있음

### 2. 속도 적응형 임계값
- Kalman 속도가 빠르면 임계값을 동적으로 증가
- 예: `dist_pred_th = base_th × (1 + speed_factor)`
- 장점: 빠른 움직임에 적응
- 단점: 속도 추정이 틀리면 문제

### 3. 방향 일관성 검사
- SAM2 center가 Kalman 속도 방향에 있으면 더 먼 거리 허용
- 예: SAM2가 예측 방향으로 멀어지면 OK, 반대 방향이면 거부
- 장점: 물리적으로 타당
- 단점: 급격한 방향 전환 시 문제

### 4. SAM2 신뢰도 기반 override
- SAM2 confidence가 매우 높으면 (>0.95) pred_ok 무시
- 장점: SAM2가 확신할 때 수락
- 단점: confidence가 항상 신뢰할 수 있는 건 아님

### 5. 거리 페널티 (하드 게이트 → 소프트 페널티)
- `pred_ok`를 boolean이 아닌 점수로 변환
- 거리가 멀수록 quality 감점, 하지만 완전 거부는 안 함
- 장점: 유연함
- 단점: 잘못된 SAM2가 낮은 quality로 수락될 수 있음

### 6. TPL/KLT 동의 시 override
- SAM2와 TPL/KLT가 동의하면 (둘 다 비슷한 위치) pred와 멀어도 수락
- 이미지 2에서 파란 네모(Kalman)가 벌레 방향을 가장 잘 추적했다는 관찰과 일치
- 장점: 교차검증 강화
- 단점: TPL/KLT도 틀릴 수 있음

---

## 권장 접근법

**단기**: 속도 적응형 임계값 (방안 2)
- 빠르게 구현 가능
- 기존 로직 유지하면서 개선

**중기**: 소프트 페널티 (방안 5) + 방향 일관성 (방안 3)
- 하드 게이트를 점수 기반으로 전환
- 물리적 타당성 추가

---

## 논의 필요 사항

1. 어떤 방안을 먼저 시도할지?
2. 임계값 튜닝 vs 로직 변경?


# ChatGPT 답변

# SAM2 마스크는 맞는데 bbox/상태가 무너지는 문제 — 수정 방향 + (옵션) 파라미터 자동화 로드맵

> 목적: **큰 점프(급격 이동)**에서도 “맞는 관측”을 버리지 않고 **재획득(reacquire)** 가능하게 만들고,  
> bbox/ROI가 과거 위치에 남아 **배경으로 퍼지는 드리프트 루프**를 끊는다.  
> **자동 파라미터 결정은 당장 적용하지 않고(단일 영상 테스트에 비효율), 안정화 후 옵션으로 둔다.**

---

## 0) 전제: 오버레이 마커 의미(코드 기준, 혼동 방지)
- **흰색 X**: `pred_center` = Kalman predict(업데이트 전 예측)
- **녹색 원**: SAM2 center
- **파란 사각형**: Template center
- **빨간 마름모**: KLT center

---

## 1) 현재 증상(요약)
- SAM2 마스크는 벌레를 따라가는데, bbox/상태가 `OCCLUDED`로 가고 bbox가 과거 위치에 남음
- 이후 ROI/추적 박스가 배경을 잡아먹으며 크게 퍼지고, 결국 추적 붕괴

---

## 2) 근본 원인(코드 레벨)
### 2.1 `qa/fusion.py`의 `pred_ok` 하드 게이트가 “재획득”을 막음
- `pred_ok = (d_pred <= dist_pred_th)`가 SAM2 채택의 문지기 역할
- 급가속/급방향전환에서 Kalman 예측이 틀어지면:
  - **SAM2가 정답이어도 거부**
  - `do_kalman_update=False` → Kalman이 회복 못 함
  - 상태는 `UNCERTAIN/OCCLUDED`로 악화 → ROI/프롬프트도 계속 틀어짐

### 2.2 bbox 갱신이 “SAM2 채택 성공”에 묶여 있음(`pipeline/runner.py`)
- SAM2 마스크가 좋아도 fusion이 SAM2를 채택하지 않으면 bbox가 갱신되지 않음
- 결과: **마스크는 이동했는데 박스는 과거 위치** → 다음 프레임 입력(prompt/ROI)이 계속 틀림

### 2.3 Template/KLT도 pred 기준에 종속되어 함께 버려짐
- Template/KLT도 `*_pred_dist <= dist_pred_th` 조건을 통과해야 채택
- Kalman이 틀어진 순간 다른 센서도 같이 버려져 붕괴 가속

---

## 3) 권장 수정안(핵심) — “SAM2 의존”이 아니라 “재획득 구조”를 만든다

### 3.1 Fusion 로직: `pred_ok`를 하드 조건 → 소프트 패널티로 전환
#### 변경 목표
- “pred에서 멀면 무조건 거부”를 제거하고,
- pred 거리(d_pred)는 **품질 점수 감점** 또는 **측정잡음(R) 조절**에만 쓰도록.

#### 제안 규칙
- `border_ok`(ROI 경계 접촉), `shape_ok`(면적/종횡비/연속성), `conf_ok`(SAM2 품질) 같은 **자체 품질**이 괜찮으면:
  - `d_pred`가 커도 SAM2 관측을 **채택**하되
  - Kalman 업데이트는 **큰 R(덜 믿는 관측)**로 수행
  - 상태는 즉시 ACTIVE 복귀시키지 말고 `UNCERTAIN` 유지(2~3프레임 확인)

> 요지: 큰 점프를 “거부”하지 말고 “약하게 반영 + 관찰”로 처리해야 Kalman이 재부착된다.

---

### 3.2 Reacquire 모드 도입(UNCERTAIN/OCCLUDED에서만)
Kalman이 틀어지는 구간에서는 pred가 기준이 되면 안 된다.  
**센서 합의(consensus)**와 SAM2 자체 품질을 우선한다.

#### Reacquire 트리거(예시)
- `state in {UNCERTAIN, OCCLUDED}` 또는 `miss_count >= k`
- 또는 `d_pred`가 큰데 `SAM2 conf`가 높고 `border_ok=True`

#### Reacquire 채택 우선순위(권장)
1) **SAM2가 있고 border_ok=True & shape_ok=True**면  
   - `d_pred`가 커도 채택(단, R 크게)
2) SAM2가 애매하면 **센서 간 합의**로 채택  
   - `dist(SAM2, KLT) < th_consensus` 또는 `dist(SAM2, TPL) < th_consensus`
   - 또는 `dist(KLT, TPL) < th_consensus`면 합의 중심을 관측으로 사용
3) 아무것도 없으면 그때만 pred-only 유지

#### ACTIVE 복귀 조건(안전장치)
- 재획득 중에는 **연속 N프레임(예: 2~3)** 동안
  - `shape_ok=True`, `border_touch 낮음`, (가능하면 센서 합의 존재)
  - 를 만족해야 ACTIVE로 승격

---

### 3.3 ROI/프롬프트 기준점 탈(脫)pred화(중요)
Kalman이 틀어졌는데 prompt/ROI도 pred 기반이면 재획득 자체가 어려움.

#### 권장
- `ACTIVE`일 때: pred 기반 유지 가능
- `UNCERTAIN/OCCLUDED`일 때:
  - `prompt_center`를 **best sensor** 기반으로 설정  
    - 우선순위 예: `SAM2(품질 ok) > KLT > TPL > pred`
  - 또는 `prompt_center = blend(pred, best_sensor, alpha)`로 중간값 사용
  - 최소한 ROI center라도 best_sensor 쪽으로 끌어준다

> ROI/프롬프트는 “다음 프레임에서 다시 찾기” 용도이므로, 확정 위치 업데이트보다 공격적으로 움직여도 안전하다.

---

### 3.4 bbox 갱신 정책 분리(드리프트 차단)
현재는 `fusion.sensor_used=="SAM2"`일 때만 bbox를 SAM2 bbox로 갱신하는 구조가 붕괴를 키움.

#### 권장 변경
- “SAM2 마스크 품질 ok”이면 `sensor_used`와 무관하게 bbox를 **즉시 SAM2 bbox로 동기화**
- 단, 트랙 상태는 `UNCERTAIN`일 수 있음(“박스 동기화”와 “확정”은 분리)

> bbox가 과거 위치에 남아 있으면 다음 프레임 입력(prompt/ROI)이 틀어져 전체가 무너진다.

---

## 4) “SAM2에 너무 의존해 퍼짐이 재발”을 막는 최소 안전장치(필수)
SAM2를 재획득에 활용하되, 퍼짐 신호가 보이면 관측을 즉시 약화/차단해야 한다.

### 4.1 면적 폭증 차단
- `mask_area`가 이전 대비 급증(예: >2~3배)하면 퍼짐 후보로 보고:
  - 관측 채택 금지 또는 R 극대화 + 상태 UNCERTAIN 유지

### 4.2 경계 접촉(border_touch) 강력 페널티
- ROI 경계를 많이 건드리는 마스크는 퍼짐/오검 가능성이 큼
- `border_touch` 높으면:
  - ACTIVE 승격 금지
  - bbox/ROI 확장 시 상한을 둠(무제한 확장 금지)

### 4.3 합의 부재 시 “확정” 금지
- 재획득 중 SAM2만 단독으로 맞는 듯 보이면:
  - bbox/ROI는 따라가되 상태는 UNCERTAIN 유지
  - 연속 프레임에서 품질 유지 + (가능하면) KLT/TPL 합의가 생길 때만 ACTIVE 복귀

---

## 5) 로그(디버깅) 추가 항목 — 이번 문제를 수치로 재현하기 위해 필수
붕괴 프레임에서 “왜 SAM2가 거부/채택되었는지”를 숫자로 확인해야 한다.

- 거리: `d_pred`, `d_klt`, `d_tpl`, `d_sam2_klt`, `d_sam2_tpl`
- 품질: `mask_area`, `area_ratio(prev)`, `aspect_ratio`, `border_touch`, `sam2_conf`
- 상태/결정: `sensor_used`, `do_kalman_update`, `R_used`, `state`, `miss_count`, `roi_size`, `bbox`

---

## 6) 파라미터 자동 결정(옵션, 지금은 보류 권장)
단일 영상 하나로만 테스트하는 단계에서는 자동화가 오히려 혼선을 만들 수 있다.  
**먼저 위 구조를 안정화한 뒤**, 여러 조건(배속/fps/벌레 크기)이 섞인 데이터에서 쓰는 게 좋다.

### 6.1 자동화 아이디어(추후)
- 입력: **시드 bbox 크기(벌레 크기 추정)** + **fps** + **분석 배속**
- 목표: 초기 threshold를 “픽셀 고정값”이 아니라 “스케일 정규화”로 세팅
  - 예: `dist_th = k * bbox_diag` 또는 `k * sqrt(area)` 형태

### 6.2 (권장) 실측 기반 1차 보정(추후)
- 시작 후 첫 N프레임 동안 채택된 중심 이동량의 `p95(px/frame)` 추정
- 이를 바탕으로 `dist_pred_th`, `reacquire_th`를 자동 스케일링
- 단, 이는 여러 영상 조건에서 통계적으로 의미가 있을 때 효율적(단일 영상 테스트엔 비효율)

---

## 7) 한 줄 요약(Claude에게)
**pred_ok 하드 게이트 때문에 "맞는 SAM2"도 버려 재획득이 막히고 bbox/ROI가 과거 위치에 남아 드리프트가 붕괴한다.
pred_ok를 소프트화하고, UNCERTAIN/OCCLUDED에서 센서 합의 기반 reacquire + prompt/ROI 탈pred화 + (SAM2 품질 ok면) bbox 즉시 동기화 + 퍼짐 안전장치(면적 폭증/경계 접촉/합의 부재 시 확정 금지)를 넣는 것이 가장 효과적이다.**

---

# Claude 구현 결과 (2026-01-31)

## 구현된 변경사항

### 1. bbox 동기화 분리 (`pipeline/runner.py:246-271`)

fusion 결정과 무관하게 SAM2 마스크 품질이 ok면 bbox를 동기화:

```python
# bbox 갱신 — SAM2 마스크 품질 ok면 sensor_used와 무관하게 동기화 (드리프트 차단)
sam2_bbox_ok = False
if sam2_result is not None and sam2_result.bbox_roi is not None:
    # SAM2 품질 체크: border_touch 낮고, 면적 폭증 아님
    border_ok = sam2_result.border_touch < 0.3
    area_ok = True
    if prev_area is not None and sam2_result.area is not None and prev_area > 0:
        area_ratio = sam2_result.area / prev_area
        area_ok = 0.3 < area_ratio < 3.0  # 면적 폭증/급감 아님
    sam2_bbox_ok = border_ok and area_ok

if sam2_bbox_ok:
    # SAM2 mask 기반 정밀 bbox (sensor_used와 무관하게 동기화)
    full_bbox = roi_mgr.to_full_coords_bbox(sam2_result.bbox_roi, roi)
    tr.bbox = full_bbox
    tr.area = sam2_result.area
elif fusion.do_kalman_update and fusion.center is not None:
    # SAM2 미사용 시 center 기반 bbox 유지 (기존 크기 보존)
    fcx, fcy = fusion.center
    if tr.bbox is not None:
        bw = tr.bbox[2] - tr.bbox[0]
        bh = tr.bbox[3] - tr.bbox[1]
    else:
        bw, bh = 60, 60
    half_w, half_h = bw // 2, bh // 2
    tr.bbox = (int(fcx - half_w), int(fcy - half_h),
               int(fcx + half_w), int(fcy + half_h))
```

### 2. pred_ok 소프트 페널티 (`qa/fusion.py:108-160`)

하드 게이트를 제거하고 pred 거리는 quality 감점 + R 증가로만 사용:

```python
# --- Case A: SAM2 자체 품질 기반 채택 (pred_ok를 소프트 페널티로 전환) ---
# 핵심 변경: pred와의 거리는 "거부 조건"이 아니라 "R/quality 조절"에만 사용
if c_sam2 is not None and sam2_trustable:
    # SAM2 자체 품질 체크 (pred와 무관)
    border_ok = (border_touch <= border_th)
    tpl_ok = (c_tpl is None) or (d_tpl <= dist_tpl_th)
    klt_ok = (c_klt is None) or (d_klt <= dist_klt_th)
    secondary_ok = tpl_ok or klt_ok

    # 면적 연속성 체크 (shape_ok)
    shape_ok = True
    if prev_area is not None and curr_area is not None and prev_area > 0:
        area_ratio = curr_area / prev_area
        shape_ok = 0.3 < area_ratio < 3.0  # 면적 폭증/급감 아님

    # SAM2 채택 조건: 자체 품질이 ok면 채택 (pred 거리와 무관)
    if border_ok and shape_ok and secondary_ok:
        # 기본 confidence에서 면적 연속성 페널티 적용
        base_quality = min(1.0, sam2.confidence if sam2 else 0.5)
        adjusted_quality = max(0.0, base_quality - area_penalty)

        # pred 거리에 따른 소프트 페널티 (거부가 아닌 감점 + R 증가)
        d_pred_norm = d_pred / max(1.0, roi_diag)
        if d_pred_norm > dist_pred_ratio:
            # pred에서 멀면: quality 감점 + R 증가 (덜 믿는 관측)
            excess_ratio = (d_pred_norm - dist_pred_ratio) / dist_pred_ratio
            pred_penalty = min(excess_ratio * 0.3, 0.4)  # 최대 0.4 감점
            adjusted_quality = max(0.0, adjusted_quality - pred_penalty)
            # R을 거리에 비례해서 증가 (최대 4배)
            r_multiplier = min(1.0 + excess_ratio * 2.0, 4.0)
            effective_r = sam2_r * r_multiplier
        else:
            effective_r = sam2_r

        # quality가 낮으면 UNCERTAIN으로 전이
        quality_uncertain_th = float(qa.get("quality_uncertain_threshold", 0.7))
        if adjusted_quality >= quality_uncertain_th:
            hint = TrackState.ACTIVE
        else:
            hint = TrackState.UNCERTAIN

        return FusionResult(
            center=c_sam2,
            sensor_used="SAM2",
            quality_score=adjusted_quality,
            do_kalman_update=True,
            measurement_r=effective_r,
            state_hint=hint,
            debug=debug,
        )
```

TPL/KLT fallback에도 동일한 소프트 페널티 적용 (lines 162-209).

### 3. 속도 기반 ROI 확장 (`pipeline/runner.py:170-192`)

빠른 이동 시 ROI를 미리 확장하여 벌레가 ROI를 벗어나기 전에 대응:

```python
# (2) 속도 기반: 빠르게 움직이면 ROI 미리 확장 (벗어나기 전에 대응)
speed_expansion = 1.0
if tr.last_center is not None:
    dx = pred_center[0] - tr.last_center[0]
    dy = pred_center[1] - tr.last_center[1]
    dist = (dx * dx + dy * dy) ** 0.5
    roi_base = roi_mgr.base_size
    r = dist / roi_base  # 이동량 / ROI 크기 비율
    if r > 0.40:
        speed_expansion = 2.0
    elif r > 0.25:
        speed_expansion = 1.5

# (3) 쿨다운 히스테리시스: 확장 후 천천히 축소 (pumping 방지)
desired_expansion = max(state_expansion, speed_expansion)
if desired_expansion > 1.0:
    tr.expansion_cooldown = 5  # 5프레임 동안 확장 유지
elif tr.expansion_cooldown > 0:
    tr.expansion_cooldown -= 1
    desired_expansion = max(desired_expansion, 1.5)  # 쿨다운 중 최소 1.5배
```

---

## 결과: 추적이 더 나빠짐

위 변경사항 적용 후 **추적 성능이 오히려 악화됨**.

### 가능한 원인 분석

1. **secondary_ok 조건 문제**: `tpl_ok or klt_ok`가 항상 True (센서가 없으면 ok)
   - TPL/KLT가 없거나 실패하면 SAM2가 무조건 채택됨
   - 잘못된 SAM2(배경 포함)도 채택되어 드리프트 유발

2. **bbox 동기화와 Kalman 불일치**:
   - bbox는 SAM2 위치로 갱신되지만 Kalman은 다른 곳을 예측
   - 다음 프레임에서 ROI center(=Kalman pred)와 bbox 위치가 다름
   - SAM2 box prompt가 엉뚱한 위치를 가리킴

3. **R 증가가 역효과**:
   - R이 커지면 Kalman이 관측을 덜 믿고 예측을 더 믿음
   - 예측이 틀린 상황에서 관측을 덜 믿으면 악순환

### 추가 확인 필요 사항

1. 디버그 로그에서 `secondary_ok`, `border_ok`, `shape_ok` 값 확인
2. SAM2가 채택될 때 마스크가 실제로 벌레인지 배경인지 확인
3. Kalman 예측과 SAM2 center 간 거리 추이 분석


# Chatgpt 답변

# Claude 수정 이후 발생한 “bbox 급점프 + SAM2 ROI 풀마스크” 문제 — 전체 정리본

## 0) 현상 요약(캡처 기준)
- 첫 큰 이동에서 **bbox가 한 프레임 만에 크게 이동(급점프)**  
  - 점프 방향/기준이 **파란 사각형(Template center)** 쪽으로 보임
- 그 직후 **SAM2 마스크가 ROI 전체로 한 번에 퍼짐(풀마스크)** → 이후 추적 붕괴
- 다른 트랙(파란 마스크)도 처음엔 정상 → 어느 순간 **한 프레임에 아래로 크게 튄 뒤 ROI 전체로 번짐**
- 공통점: **“1프레임 outlier(센터 튐) + ROI/프롬프트 오염 → 풀마스크”** 패턴

---

## 1) 왜 이런 붕괴가 가능한가(구조적 메커니즘)
SAM2(Video propagation)는 **이전 프레임 메모리 + 현재 프레임 프롬프트(box/point/ROI)**에 매우 민감함.

- 프롬프트가 한 번 크게 틀리면:
  - “무엇을 객체로 봐야 하는지” 기준이 흔들리고
  - ROI가 크거나 배경 질감이 유사하면 **ROI 전체를 채우는 마스크(풀마스크)**로 붕괴 가능
- 따라서 핵심 방어 목표는 아래 3가지임:
  1) outlier가 내부 상태(bbox/ROI/prompt/메모리)로 들어가지 못하게 차단
  2) SAM2 채택/동기화 조건이 “견제 없이 너무 쉽게” 성립하지 않게 제한
  3) ROI 확장이 풀마스크 위험을 키우지 않게 브레이크

---

## 2) Claude 변경점 중 “문제 유발 가능성이 가장 큰 부분” (우선순위)

### A) `secondary_ok`가 사실상 항상 True가 되는 설계(견제 장치 붕괴)
현재 구현(요지):

- `tpl_ok = (c_tpl is None) or (d_tpl <= dist_tpl_th)`
- `klt_ok = (c_klt is None) or (d_klt <= dist_klt_th)`
- `secondary_ok = tpl_ok or klt_ok`

문제:
- Template/KLT가 **없어도(None)** → `tpl_ok=True`, `klt_ok=True`
- `secondary_ok=True`가 **항상 성립**
- 결과적으로 SAM2 채택 조건이 거의 `border_ok & shape_ok`만 남음
- 즉 “다른 센서가 SAM2를 견제/검증”하는 구조가 사라져:
  - 잘못된 SAM2(배경 포함)도 쉽게 채택
  - outlier 1프레임이 들어오면 빠르게 붕괴

즉시 수정 권장(의도 복구):
- `c_tpl is None`이면 `tpl_ok=False`(또는 “미사용”)
- `c_klt is None`이면 `klt_ok=False`
- `secondary_ok`는 아래 중 하나로 재정의:
  - **보수형:** `c_tpl`이 존재하고 `dist(SAM2,TPL) < th_consensus` 이면 True, 또는  
    `c_klt`가 존재하고 `dist(SAM2,KLT) < th_consensus` 이면 True  
  - **모드형:** ACTIVE에서는 consensus 필수, REACQUIRE에서는 consensus 선택(아래 B)

주의:
- “항상 consensus 필수”로 고정하면 고배속에서 재획득이 다시 막힐 수 있으므로 **모드 분리(B)**가 필요함.

---

### B) ACTIVE vs REACQUIRE(UNCERTAIN/OCCLUDED) 규칙이 같아서 폭주
현재는 “SAM2 자체 품질 ok면 채택”이 전역 규칙처럼 동작하여:
- 평상시(ACTIVE)에도 SAM2 단독 채택이 쉽게 발생
- outlier 1프레임 후에도 강한 업데이트/동기화가 들어가 붕괴 가속

수정 방향(권장 설계):
- **ACTIVE(평상시):**
  - SAM2 단독 채택을 엄격히
  - shape/area continuity, border_touch, (가능하면) 2차 센서 합의(consensus) 요구
- **REACQUIRE(UNCERTAIN/OCCLUDED):**
  - pred에서 멀어도 SAM2를 “약한 관측”으로 허용 가능(재획득 목적)
  - 단, **연속 N프레임(2~3)** 안정되기 전에는 ACTIVE 승격 금지
  - “확정(Active)”과 “따라가기(ROI/bbox)”를 분리

---

### C) bbox 동기화 분리는 맞지만, 조건이 약해 “SAM2 입력(prompt) 오염”을 촉발할 수 있음
Claude 구현 요지:
- `sam2_bbox_ok = border_touch < 0.3` AND `area_ratio in [0.3, 3.0]` (단, prev_area 있을 때만)
- `sam2_bbox_ok`면 fusion과 무관하게 bbox를 SAM2 bbox로 동기화

문제:
- `prev_area`가 None이면 area 체크가 사실상 무력화(`area_ok=True`)
- 풀마스크 직전/직후에도 border_touch가 낮으면 동기화가 켜질 수 있음
- 더 치명적: bbox가 잘못 동기화되면 **다음 프레임 SAM2 prompt box/ROI가 오염**되어 풀마스크로 이어질 수 있음

수정 방향(필수 아이디어):
- bbox 업데이트를 두 층으로 분리:
  - `display_bbox`(표시/대략 위치): 비교적 공격적으로 업데이트 허용
  - `sam2_prompt_bbox`(SAM2 프롬프트용 bbox/point): **연속 안정 프레임에서만 갱신**
    - `last_good_sam2_bbox` 유지 → 2~3프레임 연속 통과 시에만 교체
- `prev_area`가 None인 구간에서는 area continuity를 “통과”가 아니라 “불확실”로 취급(보수적으로)

---

### D) 속도 기반 ROI 확장 로직이 풀마스크 위험을 키울 수 있음
Claude 구현:
- pred-last_center 기반 dist로 ROI를 1.5~2배 확장 + cooldown 유지

문제:
- pred가 틀어진 순간에도 ROI가 커짐
- 큰 ROI는 SAM2에 애매한 후보를 더 많이 제공 → 풀마스크 위험 급증
- 특히 outlier 1프레임 후 ROI가 커지면 폭주가 더 쉬움

수정 방향(브레이크):
- speed 기반 ROI 확장은 **ACTIVE에서만**
- `|pred - best_obs|`가 큰 프레임(UNCERTAIN/REACQUIRE)에서는 확장 금지(고정/상한)
- 재획득 성공 후에만 점진적 확장

---

## 3) “파란 마스크가 아래로 크게 튄 1프레임”이 원인인지
원인일 가능성이 큼.
- Template/KLT는 배경 텍스처에 붙으면 1프레임 튐(outlier)이 나올 수 있음
- 그 튐이 bbox/ROI/prompt에 반영되면:
  - SAM2가 다음 프레임에서 잘못된 영역을 객체로 전파/학습하며
  - ROI 전체를 채우는 풀마스크로 붕괴할 수 있음
- 즉, 튀는 값 자체보다 “튀는 값이 내부 상태(특히 SAM2 prompt/메모리)에 들어가는가”가 결정적임

---

## 4) 원인 확정을 위한 최소 로그 3개(강력 추천)
1) **센터가 튄(outlier) 프레임**
   - Template score(`tpl_score`) 또는 quality(q)
   - KLT status(살아있는 포인트 수, median/분산)
   - outlier인데도 center를 채택했는지 여부
2) **풀마스크 직전 프레임**
   - `prev_area`가 None이었는지(= area_ratio 체크 무력화 여부)
   - `sam2_bbox_ok`가 True로 통과했는지
   - `border_touch`, `area_ratio`, `mask_area` 값
3) **불일치(오염) 신호**
   - `center(tr.bbox)` vs `kalman pred_center` 거리
   - `sam2_center` vs `pred_center` 거리
   - 이 값이 급증하는 순간 다음 프레임 prompt가 망가졌을 확률이 큼

---

## 5) 최우선 수정 체크리스트(짧게)
- [ ] `secondary_ok` 정의 수정: 센서 없음(None)을 ok로 보지 말 것(견제 복구)
- [ ] ACTIVE vs REACQUIRE 모드 분리: 평상시 엄격, 재획득은 약한 관측 허용 + 연속 안정 후 승격
- [ ] bbox 동기화와 SAM2 prompt 업데이트 분리: `last_good_sam2_bbox` 도입(연속 통과 시에만 갱신)
- [ ] speed 기반 ROI 확장에 브레이크: UNCERTAIN/불일치 큰 프레임에서는 확장 금지/상한
- [ ] outlier 1프레임 차단: 템플릿 점수 낮거나 KLT 붕괴 시 center를 즉시 채택하지 말 것(보수화)

---

## 6) 한 줄 결론(Claude에게)
이번 악화는 `pred_ok` 하드 게이트 제거 자체가 아니라,  
**secondary_ok가 항상 True로 되어 SAM2 견제가 사라지고, prev_area None 등으로 품질 체크가 약해진 상태에서 bbox/ROI/prompt가 outlier 1프레임에 오염되며, speed 기반 ROI 확장까지 겹쳐 SAM2가 ROI 풀마스크 최악 케이스로 쉽게 붕괴한 것**으로 보임.


# ChatGpt 답변

# Insect Tracking 방향 정리 (2026-01-31)
## 목표: “급이동 1프레임”에서 ID switch(다른 대상 착각)와 SAM2 ROI 풀마스크 붕괴를 구조적으로 차단

---

## 1) 현재 근본 문제(정의)
급이동(프레임당 이동량 매우 큼) 상황에서:

1. **SAM2 마스크는 (최대 1프레임 정도) 대상(벌레)을 따라잡을 수 있음**
2. 하지만 **bbox/ROI/prompt(또는 Kalman pred 기반 입력)가 따라가지 못함**
3. 다음 프레임에서 SAM2는 **틀어진 prompt/ROI**를 보고
4. 벌레가 아닌 배경(잎/줄기 등)을 객체로 “전파/기억”하면서
5. **ROI 전체 풀마스크 / 배경 퍼짐**으로 붕괴 + ID switch 발생

핵심: “SAM2를 더 믿을지/덜 믿을지”가 아니라  
**‘SAM2 결과가 벌레인지’ 검증 없이 bbox/prompt를 갱신하여 SAM2 메모리를 오염시키는 구조**가 문제.

---

## 2) 큰 방향(해결 전략)
### A. 업데이트(갱신)와 확정(Active)을 분리
- bbox/ROI를 따라가는 것(표시/탐색)과
- “이게 진짜 벌레다”로 확정하고 상태를 ACTIVE로 복귀시키는 것을 분리한다.

### B. “벌레 형태(prior)”를 이용해 관측을 QA(품질검증)한다
벌레는 상황에 따라 길쭉하거나(펴짐) 동그랗게 말릴 수 있지만,
다음 성질은 비교적 유지된다:
- **얇은 두께(thickness)**
- **분기(branch)가 거의 없는 단일 구조**
- **시간적 연속성(두께/면적/솔리디티가 급변하지 않음)**

따라서 “길쭉함” 하나만이 아니라 **멀티-피처 worm_shape_score**로 검증한다.

### C. 의심 구간에서만 “2-가설(dual hypothesis) 재획득”을 제한적으로 수행
항상 분기하면 비용(SAM2 2회)이 너무 큼.  
**ID switch 의심(급점프/급변)**이 감지된 프레임에만, 짧게(2~3프레임) 실행한다.

---

## 3) 상태 머신(권장)
- ACTIVE: 정상 추적
- UNCERTAIN: 관측이 불안정(한 프레임 튐/불일치)
- REACQUIRE: 대상을 잃었거나 ID switch 의심 → 재획득 모드
- OCCLUDED: 가림이 강하게 의심(관측 품질이 지속적으로 낮음)

운영 원칙:
- ACTIVE → (의심 트리거) → UNCERTAIN/REACQUIRE
- REACQUIRE에서 **연속 N프레임(2~3)** 점수가 안정적으로 높을 때만 ACTIVE 복귀
- 점수가 낮은 상태에서 bbox/prompt를 “확정 갱신”하지 않는다.

---

## 4) ID switch 의심 트리거(분기/재획득 시작 조건)
아래 중 1~2개만 만족해도 REACQUIRE로 진입 가능:

### A. 위치 불일치/급점프
- dist(sam2_center, pred_center)가 ROI 대비 너무 큼
- dist(best_secondary_center, pred_center)도 비정상적으로 큼
- Template/KLT center가 1프레임에 크게 튐(outlier)

### B. SAM2 마스크 급변
- mask_area 급증/급감(예: 3배 이상)
- border_touch 급상승(ROI 경계를 크게 침범)
- worm_shape_score 급락(아래 참조)

### C. 장면 논리상 이상
- 이전까지 안정적이던 트랙이 갑자기 넓은 배경 덩어리 형태로 변함

---

## 5) 핵심: worm_shape_score 설계 (펴짐/말림 모두 대응)
형태 검증은 “길쭉함만”으로 하면 말림에서 실패한다.  
따라서 2모드(펴짐/말림)를 허용하는 점수 구조를 사용한다.

### 5.1 입력/출력(권장)
입력:
- mask (binary)
- prev_stats (마지막 good mask에서 추출한 stats)
- roi 정보(옵션: border_touch 계산에 사용)

출력:
- shape_score: 0..1
- mode_hint: "ELONGATED" | "COILED" | "UNKNOWN"
- stats: { area, perimeter, solidity, aspect_ratio, thickness_med, thickness_p90, skel_len, endpoints, branchpoints, border_touch }

### 5.2 피처(가급적 가벼운 계산)
#### A) 두께(thickness) — 말림에서도 유지되는 강한 특징
- distance transform로 마스크 내부 거리 분포 계산
- thickness_med = 2 * median(dist)
- thickness_p90 = 2 * p90(dist)
해석:
- 잎/배경 덩어리는 thickness가 커지기 쉬움
- 벌레는 상대적으로 얇은 두께 유지

#### B) 둘레 대비 면적: P² / A
- perimeter(P), area(A)로 P²/A 계산
- 가느다란 구조일수록 값이 커지는 경향
주의:
- 노이즈 경계가 P를 과대평가할 수 있으므로 모폴로지(열림/닫힘) 후 측정 권장

#### C) 솔리디티(solidity = area / convex_hull_area)
- 너무 뭉툭한 덩어리는 solidity가 특정 패턴으로 치우칠 수 있음
- 단, 절대 기준은 아님(가중치 낮게)

#### D) skeleton 기반 구조(분기/끝점)
- skeletonize 후:
  - endpoints 개수
  - branchpoints 개수
- 벌레는 일반적으로 branchpoints가 적고(거의 0), 큰 분기가 반복되면 배경 가능성↑
주의:
- 작은 객체는 skeleton이 노이즈에 민감 → 길이보다 분기/끝점 위주로 약하게 사용

#### E) 길쭉함(aspect_ratio)
- elongation(펴짐)에서는 강력
- coiled(말림)에서는 약화됨 → 모드별로 가중치 다르게

#### F) 시간 연속성(temporal continuity) — 가장 중요한 안정장치
- prev_stats가 존재할 때:
  - thickness 변화율
  - area 변화율
  - solidity 변화율
  - (가능하면) skeleton 분기 변화
- “급이동”은 허용하되, “두께/면적/경계 특성의 급변”은 강한 페널티

### 5.3 모드 판정(간단 휴리스틱)
- aspect_ratio가 낮아졌는데(예: < 2.0)
- thickness_med/thickness_p90이 prev 대비 크게 변하지 않고
- area도 크게 변하지 않으면
→ COILED 후보로 판단

### 5.4 점수 결합(예시 컨셉)
- ELONGATED 모드:
  - aspect_ratio, skeleton 단일 구조(분기 적음), thickness, continuity를 가중합
- COILED 모드:
  - thickness, P²/A, continuity 중심
  - aspect_ratio 가중치 낮춤
- 어떤 모드든:
  - border_touch가 높으면 강한 페널티
  - 면적 폭증/두께 폭증은 강한 페널티(배경 퍼짐 가능)

---

## 6) “2-가설(dual hypothesis) 재획득” 설계 (의심 구간에서만)
### 6.1 가설 정의
- H1: Follow SAM2
  - 직전 SAM2 결과 기반 prompt/center로 SAM2 실행
- H2: Follow Secondary (Kalman/Template/KLT)
  - best_secondary_center 기반 prompt/center로 SAM2 실행

### 6.2 선택 규칙
각 가설의 SAM2 결과 마스크 M1/M2에 대해:

score(M) =
- + w_shape * worm_shape_score(M)
- + w_temp  * temporal_consistency(M, last_good_stats)
- + w_motion * motion_plausibility(center(M), pred_center)
- - w_border * border_touch(M)
- - w_blowup * area/thickness blowup penalties

승자:
- score가 더 높은 가설을 선택
- 단, 1프레임만으로 확정하지 말고 **연속 N프레임(2~3)** 승리 시 ACTIVE 복귀

### 6.3 메모리/프롬프트 오염 방지(필수 안전장치)
- REACQUIRE 구간에서는:
  - “승자 가설”의 결과만 SAM2 prompt 업데이트(또는 last_good 갱신)에 반영
  - 패자 가설 결과로 bbox/prompt 업데이트 금지
- shape_score가 낮으면:
  - bbox를 화면 표시용으로만 갱신(옵션)하고
  - SAM2 prompt bbox는 last_good을 유지

---

## 7) bbox/ROI 업데이트 정책(중요)
### 7.1 bbox를 두 종류로 분리(권장)
- display_bbox: UI 표시/대략 추적용 (조금 공격적으로 움직여도 됨)
- prompt_bbox: SAM2에 다시 주는 프롬프트용 (오염되면 즉시 붕괴)

정책:
- prompt_bbox는 “연속 안정 프레임(2~3)”에서만 갱신
- shape_score 낮거나 outlier 의심 시에는 prompt_bbox 동결(hold)

### 7.2 ROI 확장(속도 기반)은 브레이크가 있어야 함
- ACTIVE에서만 속도 기반 확장 허용
- UNCERTAIN/REACQUIRE에서는:
  - pred와 관측 불일치가 큰 프레임에서 확장 금지(고정/상한)
  - ROI가 커질수록 풀마스크 위험이 올라감

---

## 8) 단일 영상 테스트 단계에서의 권장 구현 순서(실패율 낮추기)
1) worm_shape_score부터 구현하고, 기존 SAM2 결과에 대해 점수 로깅/시각화
2) shape_score 낮은 프레임에서는 prompt_bbox 업데이트를 “금지/동결”하도록만 먼저 적용
3) 그 다음 REACQUIRE 모드 + “연속 N프레임 안정” 승격 규칙 추가
4) 마지막으로(필요할 때만) dual hypothesis 분기를 의심 구간에서 2~3프레임 실행

---

## 9) 최소 디버그 로그(필수)
프레임별로 다음을 남긴다(텍스트 + 필요 시 overlay):
- centers: pred, sam2, tpl, klt, chosen
- distances: d_pred_sam2, d_pred_tpl, d_pred_klt, d_sam2_tpl, d_sam2_klt
- mask stats: area, perimeter, solidity, border_touch
- thickness stats: thickness_med, thickness_p90
- skeleton stats: endpoints, branchpoints
- mode_hint: ELONGATED/COILED
- shape_score, temporal_score, final_score
- state: ACTIVE/UNCERTAIN/REACQUIRE/OCCLUDED
- prompt_bbox update 여부(갱신/동결) 및 last_good 갱신 여부

---

## 10) 판단 기준(성공/실패)
성공:
- 급이동 프레임에서도 “한 프레임 튐”이 발생해도 prompt_bbox 오염 없이 복구
- SAM2가 ROI 전체 풀마스크로 번지는 케이스가 크게 감소
- ID switch가 발생하더라도 REACQUIRE에서 2~3프레임 내 정상 대상 재획득

실패(바로 수정해야 할 신호):
- shape_score 낮은데도 prompt_bbox가 갱신됨
- REACQUIRE에서 1프레임만 보고 ACTIVE로 즉시 복귀(너무 공격적)
- ROI 확장이 UNCERTAIN에서도 계속 커지며 풀마스크 빈도 증가


# GPT 답변

# 디버깅/평가 로그 시스템 제안 (사람 + Claude 공용)
## 목표: 영상 전체를 보지 않아도 “추적이 좋아졌는지 / 어디서 왜 무너지는지”를 판단 가능하게 만들기

---

## 1) 산출물(출력 파일) 패키지 — 최소/권장 구성
### A. 프레임 단위 구조화 로그 (필수)
- `debug_frames.jsonl` : 프레임당 1줄 JSON (확장/재분석/자동화에 최적)
- `debug_frames.csv` : 엑셀/판다스 필터링용 (사람이 보기 쉬움)

### B. 자동 이벤트 요약 (필수)
- `events.md` : 이상징후/전이/분기 결과를 “사람이 읽는 문장”으로 요약
  - 예: `F0123 AREA_BLOWUP(x4.8)+BORDER_TOUCH_HIGH(0.62) -> REACQUIRE`

### C. Top-K 스냅샷 (권장)
- `snapshots/frame_XXXX.png` : 이벤트 프레임만 저장 (영상 대신 몇 장만 확인)
- 오버레이에 수치/상태/결정근거를 텍스트로 표시

### D. 런 요약 (권장)
- `run_summary.json` : 전체 지표(비율/카운트/성공률) 요약
- (선택) `report.html` : 요약+이벤트+스냅샷+그래프를 한 페이지로 보기

---

## 2) 프레임 레코드 스키마(핵심 필드) — JSONL/CSV 공통
### 2.1 상태/결정
- `frame_idx`, `t_sec`
- `state` : ACTIVE / UNCERTAIN / REACQUIRE / OCCLUDED
- `sensor_used` : SAM2 / TPL / KLT / PRED / CONSENSUS
- `do_kalman_update` (bool), `measurement_r`
- `reason_flags` : ["AREA_BLOWUP", "PROMPT_POISON_RISK", ...]

### 2.2 좌표(모두 full-frame 기준 통일)
- `pred_center_xy`
- `sam2_center_xy`
- `tpl_center_xy`
- `klt_center_xy`
- `chosen_center_xy`
- 거리들:
  - `d_pred_sam2`, `d_pred_tpl`, `d_pred_klt`
  - `d_sam2_tpl`, `d_sam2_klt`

### 2.3 ROI / bbox / prompt
- `roi_xyxy`, `roi_center_xy`, `roi_scale`
- `bbox_xyxy` (display_bbox)
- `prompt_bbox_xyxy` (SAM2 프롬프트용 bbox가 따로면 필수)
- `prompt_bbox_update` : HOLD / UPDATE
- `last_good_update` (bool)

### 2.4 SAM2 마스크 품질/형태(필수)
- `mask_area`, `area_ratio_prev`
- `border_touch`
- `perimeter`, `solidity`, `p2_over_a` (P^2/A)
- `aspect_ratio`
- `thickness_med`, `thickness_p90` (Distance Transform 기반)
- (가능하면) `endpoints`, `branchpoints`, `skeleton_len`
- 최종 평가:
  - `shape_mode` : ELONGATED / COILED / UNKNOWN
  - `shape_score` (0..1), `temporal_score` (0..1), `final_score` (0..1)

### 2.5 분기(dual hypothesis) 사용 시
- `branch_active` (bool)
- `score_h1_sam2`, `score_h2_secondary`
- `branch_winner` : H1 / H2 / NONE

---

## 3) 자동 이상징후 플래그(핵심) — “봐야 할 프레임”을 줄이는 장치
추천 플래그(효과 큰 것만):
- `AREA_BLOWUP` : `area_ratio_prev > 3.0` or `< 0.3`
- `THICKNESS_BLOWUP` : `thickness_p90` 급증(prev 대비)
- `BORDER_TOUCH_HIGH` : `border_touch > 0.35` (예시)
- `CENTER_JUMP_OUTLIER` : chosen_center의 프레임간 이동이 비정상
- `CONSENSUS_BREAK` : SAM2와 TPL/KLT 모두 거리 큼
- `PROMPT_POISON_RISK` : shape_score 낮은데 `prompt_bbox_update=UPDATE`
- `ROI_EXPAND_DURING_UNCERTAIN` : UNCERTAIN/REACQUIRE인데 roi_scale 증가
- `ID_SWITCH_SUSPECT` : shape/area/thickness가 동시에 “배경 덩어리” 쪽으로 급변

`events.md`는 위 플래그와 상태 전이를 기반으로 자동 생성한다.

---

## 4) “벌레 형태 인식” 방법(길쭉함 + 말림 포함) — shape_mode + shape_score
### 4.1 핵심 원칙
- 길쭉함(aspect_ratio)만으로 판정하면 말림(coiled)에서 실패
- 말림에서도 비교적 유지되는 특성(두께/연속성)을 중심으로 점수화
- 결과: `shape_mode`(ELONGATED/COILED/UNKNOWN) + `shape_score`(0..1)

### 4.2 형태 피처(가벼운 연산 위주)
- **두께(thickness)**: Distance Transform
  - `thickness_med = 2 * median(dist)`
  - `thickness_p90 = 2 * p90(dist)`
- **길쭉함**: `aspect_ratio = major_axis / minor_axis` (PCA/타원/rotated bbox)
- **가느다란 구조 지표**: `p2_over_a = perimeter^2 / area`
- **solidity**: `area / convex_hull_area` (보조)
- **skeleton 구조(가능하면)**:
  - `endpoints`, `branchpoints` (벌레는 분기 적은 단일 구조 경향)
- **시간 연속성(필수)**:
  - area/thickness/solidity 변화율이 급변하면 강한 페널티

### 4.3 shape_mode 판정(휴리스틱)
- COILED 후보:
  - aspect_ratio 낮음(예: < 2.0)
  - thickness, area가 prev 대비 폭증하지 않음
- ELONGATED 후보:
  - aspect_ratio 충분히 큼(예: > 3.0)
- UNKNOWN:
  - area/thickness 폭증, border_touch 상승 등 풀마스크/배경 의심

### 4.4 점수 결합(개념)
- ELONGATED 모드:
  - aspect_ratio 비중 ↑, thickness/연속성/분기 억제 포함
- COILED 모드:
  - thickness + p2_over_a + 연속성 비중 ↑, aspect_ratio 비중 ↓
- 공통 페널티:
  - border_touch 높음, area/thickness blowup, 분기 과다

---

## 5) 사람이/Claude가 쉽게 확인하는 워크플로우(권장)
### A) 빠른 1차 판단(영상 없이)
1) `run_summary.json` : 풀마스크 이벤트/오염 위험/복구 성공률 카운트 확인
2) `events.md` : 문제 구간(프레임)과 원인 플래그 확인
3) `debug_frames.csv` : 해당 프레임 주변(±20)만 필터링해서 수치 추이 확인

### B) 필요한 경우만 이미지로 확인
- `snapshots/frame_XXXX.png`만 확인 (이벤트 프레임 Top-K)
- 오버레이에 state/sensor/shape_score/mode/area_ratio/thickness/border_touch/prompt_update 표시

---

## 6) 오버레이(스냅샷/영상) 표준 표시(권장)
화면 좌상단 텍스트:
- `state`, `sensor_used`, `shape_mode`, `shape_score`
- `mask_area`, `area_ratio_prev`, `border_touch`
- `thickness_med`, `thickness_p90`
- `prompt_bbox_update(HOLD/UPDATE)`, `last_good_update`
- `reason_flags` 상위 3개

도형 표시:
- ROI 박스, display_bbox, prompt_bbox는 색을 다르게(혼동 방지)
- centers(pred/sam2/tpl/klt/chosen)도 색으로 구분

---

## 7) 구현 우선순위(최소 비용으로 최대 효과)
1) `debug_frames.jsonl/csv` + `reason_flags`
2) `events.md` 자동 생성(플래그/전이 기반)
3) 이벤트 프레임 `snapshots/` 저장 + 오버레이 텍스트 강화
4) (선택) `report.html`로 한 페이지 뷰어 제공
